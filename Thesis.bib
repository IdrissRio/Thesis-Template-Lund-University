
@article{DBLP:journals/informaticaSI/Hedin00,
	title        = {Reference Attributed Grammars},
	author       = {G{\"{o}}rel Hedin},
	year         = 2000,
	journal      = {Informatica (Slovenia)},
	volume       = 24,
	number       = 3,
	timestamp    = {Mon, 15 Feb 2016 15:01:43 +0100},
	biburl       = {https://dblp.org/rec/journals/informaticaSI/Hedin00.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{DBLP:conf/oopsla/EkmanH07,
	title        = {The jastadd extensible java compiler},
	author       = {Torbj{\"{o}}rn Ekman and G{\"{o}}rel Hedin},
	year         = 2007,
	booktitle    = {Proceedings of the 22nd Annual {ACM} {SIGPLAN} Conference on Object-Oriented Programming, Systems, Languages, and Applications, {OOPSLA} 2007, October 21-25, 2007, Montreal, Quebec, Canada},
	publisher    = {{ACM}},
	pages        = {1--18},
	doi          = {10.1145/1297027.1297029},
	url          = {https://doi.org/10.1145/1297027.1297029},
	editor       = {Richard P. Gabriel and David F. Bacon and Cristina Videira Lopes and Guy L. Steele Jr.},
	timestamp    = {Fri, 25 Jun 2021 14:48:54 +0200},
	biburl       = {https://dblp.org/rec/conf/oopsla/EkmanH07.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}
@article{DBLP:journals/entcs/HedinM01,
	title        = {JastAdd - a Java-based system for implementing front ends},
	author       = {G{\"{o}}rel Hedin and Eva Magnusson},
	year         = 2001,
	journal      = {Electron. Notes Theor. Comput. Sci.},
	volume       = 44,
	number       = 2,
	pages        = {59--78},
	doi          = {10.1016/S1571-0661(04)80920-4},
	url          = {https://doi.org/10.1016/S1571-0661(04)80920-4},
	timestamp    = {Fri, 12 Feb 2021 22:17:06 +0100},
	biburl       = {https://dblp.org/rec/journals/entcs/HedinM01.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}
@article{allen1970control,
	title        = {Control flow analysis},
	author       = {Allen, Frances E},
	year         = 1970,
	journal      = {ACM Sigplan Notices},
	publisher    = {ACM New York, NY, USA},
	volume       = 5,
	number       = 7,
	pages        = {1--19}
}
@book{aho2007compilers,
	title        = {Compilers: principles, techniques, \& tools},
	author       = {Aho, Alfred V and Lam, Monica S and Sethi, Ravi and Ullman, Jeffrey D},
	year         = 2007,
	publisher    = {Pearson Education India}
}
@book{appel2004modern,
	title        = {Modern compiler implementation in C},
	author       = {Appel, Andrew W},
	year         = 2004,
	publisher    = {Cambridge university press}
}
@article{ayewah2008using,
	title        = {Using static analysis to find bugs},
	author       = {Ayewah, Nathaniel and Pugh, William and Hovemeyer, David and Morgenthaler, J David and Penix, John},
	year         = 2008,
	journal      = {IEEE software},
	publisher    = {IEEE},
	volume       = 25,
	number       = 5,
	pages        = {22--29}
}
@inproceedings{LLVM,
	title        = {LLVM: a compilation framework for lifelong program analysis \& transformation},
	author       = {Lattner, C. and Adve, V.},
	year         = 2004,
	booktitle    = {International Symposium on Code Generation and Optimization, 2004. CGO 2004.},
	volume       = {},
	number       = {},
	pages        = {75--86},
	doi          = {10.1109/CGO.2004.1281665}
}
@book{javaBytecode,
	title        = {The Java Virtual Machine Specification, Java SE 7 Edition: Java Virt Mach Spec Java\_3},
	author       = {Lindholm, Tim and Yellin, Frank and Bracha, Gilad and Buckley, Alex},
	year         = 2013,
	publisher    = {Addison-Wesley}
}
@article{kam1977monotone,
	title        = {Monotone data flow analysis frameworks},
	author       = {Kam, John B and Ullman, Jeffrey D},
	year         = 1977,
	journal      = {Acta informatica},
	publisher    = {Springer},
	volume       = 7,
	number       = 3,
	pages        = {305--317}
}
@misc{spa,
	title        = {Static Program Analysis},
	author       = {Anders M\o{}ller and Michael I. Schwartzbach},
	year         = 2018,
	month        = {October},
	url          = {\url{http://cs.au.dk/\~{}amoeller/spa/}},
	note         = {Department of Computer Science, Aarhus University},
	howpublished = {\url{http://cs.au.dk/\~amoeller/spa/}}
}
@article{knuth1968semantics,
	title        = {Semantics of context-free languages},
	author       = {Knuth, Donald E},
	year         = 1968,
	journal      = {Mathematical systems theory},
	publisher    = {Springer},
	volume       = 2,
	number       = 2,
	pages        = {127--145}
}
@article{Sayar_2022,
	title        = {An In-depth Study of Java Deserialization Remote-Code Execution Exploits and Vulnerabilities},
	author       = {Imen Sayar and Alexandre Bartel and Eric Bodden and Yves Le Traon},
	year         = 2022,
	month        = {aug},
	journal      = {{ACM} Transactions on Software Engineering and Methodology},
	publisher    = {Association for Computing Machinery ({ACM})},
	doi          = {10.1145/3554732},
	url          = {https://doi.org/10.1145%2F3554732}
}
@book{khedker2017data,
	title        = {Data flow analysis: theory and practice},
	author       = {Khedker, Uday and Sanyal, Amitabha and Sathe, Bageshri},
	year         = 2017,
	publisher    = {CRC Press}
}
@misc{sonarqube,
	title        = {SonarQube: Continuous Code Quality},
	author       = {SonarSource},
	publisher    = {SonarSource},
	note         = {Accessed: 2023-01-27},
	howpublished = {\url{https://www.sonarqube.org/}}
}
@misc{Valgrind,
	title        = {Valgrind: A Framework for Memory Debugging, Profiling and Analysis},
	author       = {Open Source Development Lab},
	year         = 2003,
	note         = {Accessed: 2023-01-27},
	howpublished = {\url{http://www.valgrind.org/}}
}
@misc{Intel,
	title        = {Intel VTune Amplifier},
	year         = 2021,
	publisher    = {Intel Corporation},
	note         = {Accessed: 2023-01-27},
	howpublished = {\url{https://software.intel.com/en-us/vtune}}
}
@article{nielson1999type,
	title        = {Type and effect systems},
	author       = {Nielson, Flemming and Nielson, Hanne Riis},
	year         = 1999,
	journal      = {Correct System Design: Recent Insights and Advances},
	publisher    = {Springer},
	pages        = {114--136}
}
@book{laddad2003aspectj,
	title        = {AspectJ in action: practical aspect-oriented programming},
	author       = {Laddad, Ramnivas},
	year         = 2003,
	publisher    = {Dreamtech Press}
}
@inproceedings{vogt89pldi,
	title        = {Higher Order Attribute Grammars},
	author       = {Vogt, H. H. and Swierstra, S. D. and Kuiper, M. F.},
	year         = 1989,
	booktitle    = {Proceedings of the ACM SIGPLAN 1989 Conference on Programming Language Design and Implementation},
	location     = {Portland, Oregon, USA},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {PLDI '89},
	pages        = {131–145},
	doi          = {10.1145/73141.74830},
	isbn         = {089791306X},
	url          = {https://doi.org/10.1145/73141.74830},
	abstract     = {A new kind of attribute grammars, called higher order attribute grammars, is defined. In higher order attribute grammars the structure tree can be expanded as a result of attribute computation. A structure tree may be stored in an attribute. The term higher order is used because of the analogy with higher order functions, where a function can be the result or parameter of another function. A relatively simple method, using OAGs, is described to derive an evaluation order on the defining attribute occurrences which comprises all possible direct and indirect attribute dependencies. As in OAGs, visit-sequences are computed from which an efficient algorithm for attribute evaluation can be derived.},
	numpages     = 15
}
@article{vogt1989higher,
	title        = {Higher Order Attribute Grammars},
	author       = {Vogt, H. H. and Swierstra, S. D. and Kuiper, M. F.},
	year         = 1989,
	month        = {jun},
	journal      = {SIGPLAN Not.},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 24,
	number       = 7,
	pages        = {131–145},
	doi          = {10.1145/74818.74830},
	issn         = {0362-1340},
	url          = {https://doi.org/10.1145/74818.74830},
	issue_date   = {July 1989},
	abstract     = {A new kind of attribute grammars, called higher order attribute grammars, is defined. In higher order attribute grammars the structure tree can be expanded as a result of attribute computation. A structure tree may be stored in an attribute. The term higher order is used because of the analogy with higher order functions, where a function can be the result or parameter of another function. A relatively simple method, using OAGs, is described to derive an evaluation order on the defining attribute occurrences which comprises all possible direct and indirect attribute dependencies. As in OAGs, visit-sequences are computed from which an efficient algorithm for attribute evaluation can be derived.},
	numpages     = 15
}
@article{MAGNUSSON200721,
	title        = {Circular reference attributed grammars — their evaluation and applications},
	author       = {Eva Magnusson and Görel Hedin},
	year         = 2007,
	journal      = {Science of Computer Programming},
	volume       = 68,
	number       = 1,
	pages        = {21--37},
	doi          = {https://doi.org/10.1016/j.scico.2005.06.005},
	issn         = {0167-6423},
	url          = {https://www.sciencedirect.com/science/article/pii/S0167642307000767},
	note         = {Special Issue on the ETAPS 2003 Workshop on Language Descriptions, Tools and Applications (LDTA ’03)},
	keywords     = {Attribute grammars, Circular attribute evaluation, Reference attributes, Fixed-point evaluation, Demand-driven evaluation, Grammar flow, Live analysis},
	abstract     = {This paper presents a combination of Reference Attributed Grammars (RAGs) and Circular Attribute Grammars (CAGs). While RAGs allow the direct and easy specification of nonlocally dependent information, CAGs allow iterative fixed-point computations to be expressed directly using recursive (circular) equations. We demonstrate how the combined formalism, Circular Reference Attributed Grammars (CRAGs), can take advantage of both these strengths, making it possible to express solutions to many problems in an easy way. We exemplify with the specification and computation of the nullable, first, and follow sets used in parser construction, a problem which is highly recursive and normally programmed by hand using an iterative algorithm. We also present a general demand-driven evaluation algorithm for CRAGs and some optimizations of it. The approach has been implemented and experimental results include computations on a series of grammars including that of Java 1.2. We also revisit some of the classical examples of CAGs and show how their solutions are facilitated by CRAGs.}
}
@inproceedings{Magnusson2007ExtendingAG,
	title        = {Extending Attribute Grammars with Collection Attributes--Evaluation and Applications},
	author       = {Magnusson, Eva and Ekman, Torbjorn and Hedin, Gorel},
	year         = 2007,
	booktitle    = {Seventh IEEE International Working Conference on Source Code Analysis and Manipulation (SCAM 2007)},
	volume       = {},
	number       = {},
	pages        = {69--80},
	doi          = {10.1109/SCAM.2007.13}
}
@article{KrishnamurthiArtifact2013,
	title        = {Artifact Evaluation for Software Conferences},
	author       = {Krishnamurthi, Shriram},
	year         = 2013,
	month        = {may},
	journal      = {SIGSOFT Softw. Eng. Notes},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 38,
	number       = 3,
	pages        = {7–10},
	doi          = {10.1145/2464526.2464530},
	issn         = {0163-5948},
	url          = {https://doi.org/10.1145/2464526.2464530},
	issue_date   = {May 2013},
	abstract     = {Software and other digital artifacts are amongst the most valuable contributions of computer science. Yet our conferences treat these mostly as second-class artifacts--especially conferences in the software sciences, which ought to know better. This article argues for elevating these other artifacts by making them part of the evaluation process for papers, and reports on experience from an iteration of an Artifact Evaluation Committee for ESEC/FSE 2011.},
	numpages     = 4
}
@article{jasz2019systematic,
	title        = {Systematic comparison of six open-source Java call graph construction tools},
	author       = {J{\'a}sz, Judit and Siket, Istv{\'a}n and Peng{\H{o}}, Edit and S{\'a}godi, Zolt{\'a}n and Ferenc, Rudolf},
	year         = 2019,
	publisher    = {Science and Technology Press}
}
@inproceedings{steensgaard1996points,
	title        = {Points-to analysis in almost linear time},
	author       = {Bjarne Steensgaard},
	year         = 1996,
	booktitle    = {Proceedings of the 23rd ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
	pages        = {32--41}
}
@inproceedings{DuBose2012ReconcilingMA,
	title        = {Reconciling manual and automatic refactoring},
	author       = {Ge, Xi and DuBose, Quinton L. and Murphy-Hill, Emerson},
	year         = 2012,
	booktitle    = {2012 34th International Conference on Software Engineering (ICSE)},
	volume       = {},
	number       = {},
	pages        = {211--221},
	doi          = {10.1109/ICSE.2012.6227192}
}
@inproceedings{SootJavaBytecode2010,
	title        = {Soot: A Java Bytecode Optimization Framework},
	author       = {Vall\'{e}e-Rai, Raja and Co, Phong and Gagnon, Etienne and Hendren, Laurie and Lam, Patrick and Sundaresan, Vijay},
	year         = 2010,
	booktitle    = {CASCON First Decade High Impact Papers},
	location     = {Toronto, Ontario, Canada},
	publisher    = {IBM Corp.},
	address      = {USA},
	series       = {CASCON '10},
	pages        = {214–224},
	doi          = {10.1145/1925805.1925818},
	url          = {https://doi.org/10.1145/1925805.1925818},
	abstract     = {This paper presents Soot, a framework for optimizing Java* bytecode. The framework is implemented in Java and supports three intermediate representations for representing Java bytecode: Baf, a streamlined representation of bytecode which is simple to manipulate; Jimple, a typed 3-address intermediate representation suitable for optimization; and Grimp, an aggregated version of Jimple suitable for decompilation. We describe the motivation for each representation, and the salient points in translating from one representation to another.In order to demonstrate the usefulness of the framework, we have implemented intraprocedural and whole program optimizations. To show that whole program bytecode optimization can give performance improvements, we provide experimental results for 12 large benchmarks, including 8 SPECjvm98 benchmarks running on JDK 1.2 for GNU/Linuxtm. These results show up to 8% improvement when the optimized bytecode is run using the interpreter and up to 21% when run using the JIT compiler.},
	numpages     = 11
}
@inproceedings{farrow1986automatic,
	title        = {Automatic generation of fixed-point-finding evaluators for circular, but well-defined, attribute grammars},
	author       = {Rodney Farrow},
	year         = 1986,
	booktitle    = {Proceedings of the 1986 {SIGPLAN} Symposium on Compiler Construction, Palo Alto, California, USA, June 25-27, 1986},
	publisher    = {{ACM}},
	pages        = {85--98},
	doi          = {10.1145/12276.13320},
	url          = {https://doi.org/10.1145/12276.13320}
}


@inproceedings{jones1986hierarchical,
	title        = {Hierarchical {VLSI} Design Systems Based on Attribute Grammars},
	author       = {Larry G. Jones and Janos Simon},
	year         = 1986,
	booktitle    = {Conference Record of the Thirteenth Annual {ACM} Symposium on Principles of Programming Languages, St. Petersburg Beach, Florida, USA, January 1986},
	publisher    = {{ACM} Press},
	pages        = {58--69},
	doi          = {10.1145/512644.512650},
	url          = {https://doi.org/10.1145/512644.512650}
}
@inproceedings{arzt2014reviser,
	title        = {Reviser: efficiently updating IDE-/IFDS-based data-flow analyses in response to incremental program changes},
	author       = {Arzt, Steven and Bodden, Eric},
	year         = 2014,
	booktitle    = {Proceedings of the 36th International Conference on Software Engineering},
	pages        = {288--298}
}

@inproceedings{bodden2018secret,
  author    = {Bodden, Eric},
  title     = {The secret sauce in efficient and precise static analysis: the beauty of distributive, summary-based static analyses (and how to master them)},
  year      = {2018},
  isbn      = {9781450359399},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3236454.3236500},
  doi       = {10.1145/3236454.3236500},
  abstract  = {In this paper I report on experiences gained from more than five years of extensively designing static code analysis tools- in particular such ones with a focus on security- to scale to real-world projects within an industrial context. Within this time frame, my team and I were able to design static-analysis algorithms that yield both largely improved precision and performance compared to previous approaches. I will give a number of insights regarding important design decisions that made this possible.In particular, I argue that summary-based static-analysis techniques for distributive problems, such as IFDS, IDE and WPDS have been unduly under-appreciated. As my experience shows, those techniques can tremendously benefit both precision and performance, if one uses them in a well-informed way, using carefully designed abstract domains. As one example, I will explain how in previous work on BOOMERANG we were able to decompose pointer analysis, a static analysis problem that is actually not distributive, into sub-problems that are distributive. This yields an implementation that is both highly precise and efficient.This breakthrough, along with the use of a demand-driven program-analysis design, has recently allowed us to implement practical static analysis tools such as the crypto-misuse checker CogniCrypt, which can analyze the entire Maven-Central repository with more than 200.000 binaries in under five days, although its analysis is flow-sensitive, field-sensitive, and fully context-sensitive.},
  booktitle = {Companion Proceedings for the ISSTA/ECOOP 2018 Workshops},
  pages     = {85–93},
  numpages  = {9},
  keywords  = {summarization, static analysis, precision, performance, abstract domains},
  location  = {Amsterdam, Netherlands},
  series    = {ISSTA '18}
}

@inproceedings{reps1995precise,
	title        = {Precise interprocedural dataflow analysis via graph reachability},
	author       = {Reps, Thomas and Horwitz, Susan and Sagiv, Mooly},
	year         = 1995,
	booktitle    = {Proceedings of the 22nd ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
	pages        = {49--61}
}
@article{sagiv1996precise,
	title        = {Precise interprocedural dataflow analysis with applications to constant propagation},
	author       = {Sagiv, Mooly and Reps, Thomas and Horwitz, Susan},
	year         = 1996,
	journal      = {Theoretical Computer Science},
	publisher    = {Elsevier},
	volume       = 167,
	number       = {1-2},
	pages        = {131--170}
}


@book{DBLP:books/mk/GrayR93,
	title        = {Transaction Processing: Concepts and Techniques},
	author       = {Jim Gray and Andreas Reuter},
	year         = 1993,
	publisher    = {Morgan Kaufmann},
	isbn         = {1-55860-190-2},
	timestamp    = {Thu, 05 Nov 2015 19:53:28 +0100},
	biburl       = {http://dblp.uni-trier.de/rec/bib/books/mk/GrayR93},
	bibsource    = {dblp computer science bibliography, http://dblp.org}
}
@inproceedings{DBLP:conf/focs/HopcroftPV75,
	title        = {On Time versus Space and Related Problems},
	author       = {{John E.} Hopcroft and {Wolfgang J.} Paul and {Leslie G.} Valiant},
	year         = 1975,
	booktitle    = {16th Annual Symposium on Foundations of Computer Science, Berkeley, California, USA, October 13-15, 1975},
	pages        = {57--64},
	doi          = {10.1109/SFCS.1975.23},
	crossref     = {DBLP:conf/focs/FOCS16},
	timestamp    = {Tue, 16 Dec 2014 09:57:24 +0100},
	biburl       = {http://dblp.uni-trier.de/rec/bib/conf/focs/HopcroftPV75},
	bibsource    = {dblp computer science bibliography, http://dblp.org}
}
@proceedings{DBLP:conf/focs/FOCS16,
	title        = {16th Annual Symposium on Foundations of Computer Science, Berkeley, California, USA, October 13-15, 1975},
	year         = 1975,
	publisher    = {{IEEE} Computer Society},
	timestamp    = {Mon, 15 Dec 2014 18:48:44 +0100},
	biburl       = {http://dblp.uni-trier.de/rec/bib/conf/focs/FOCS16},
	bibsource    = {dblp computer science bibliography, http://dblp.org}
}
@inproceedings{hovemeyer2005evaluating,
	title        = {Evaluating and tuning a static analysis to find null pointer bugs},
	author       = {Hovemeyer, David and Spacco, Jaime and Pugh, William},
	year         = 2005,
	booktitle    = {Proceedings of the 6th ACM SIGPLAN-SIGSOFT workshop on Program analysis for software tools and engineering},
	pages        = {13--19}
}
@inproceedings{smith2015questions,
	title        = {Questions developers ask while diagnosing potential security vulnerabilities with static analysis},
	author       = {Smith, Justin and Johnson, Brittany and Murphy-Hill, Emerson and Chu, Bill and Lipford, Heather Richter},
	year         = 2015,
	booktitle    = {Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering},
	pages        = {248--259}
}
@article{10.1016/j.scico.2012.02.002,
	title        = {Extensible Intraprocedural Flow Analysis at the Abstract Syntax Tree Level},
	author       = {S{\"{o}}derberg, Emma and Ekman, Torbj\"{o}rn and Hedin, G\"{o}rel and Magnusson, Eva},
	year         = 2013,
	month        = oct,
	journal      = {Sci. Comput. Program.},
	publisher    = {Elsevier North-Holland, Inc.},
	address      = {USA},
	volume       = 78,
	number       = 10,
	pages        = {1809–1827},
	doi          = {10.1016/j.scico.2012.02.002},
	issn         = {0167-6423},
	url          = {https://doi.org/10.1016/j.scico.2012.02.002},
	issue_date   = {October, 2013},
	abstract     = {We have developed a new approach for implementing precise intraprocedural control-flow and dataflow analyses at the abstract syntax tree level. Our approach is declarative, making use of reference attribute grammars augmented with circular attributes and collection attributes. This results in concise executable specifications of the analyses, allowing extensions both to the language and with further source code analyses. To evaluate the new approach, we have implemented control flow, dataflow and dead assignment analyses for Java, by extending the JastAdd Extensible Java Compiler. We have compared our results to several well-known analysis frameworks and tools, using a set of Java programs as benchmarks. These results show that our approach performs well concerning both efficiency and preciseness.},
	numpages     = 19,
	keywords     = {Compiler, Declarative, Dataflow, Attribute grammars, Analysis, Java, Control-flow}
}

@inproceedings{oqvist2013extending,
  author    = {\"{O}qvist, Jesper and Hedin, G\"{o}rel},
  title     = {Extending the JastAdd extensible Java compiler to Java 7},
  year      = {2013},
  isbn      = {9781450321112},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2500828.2500843},
  doi       = {10.1145/2500828.2500843},
  abstract  = {JastAddJ is an extensible Java compiler, implemented using reference attribute grammars. It has been shown previously how the language constructs of Java 5, like generics, could be modularly added to the original JastAddJ compiler that supported Java 1.4.In this paper we discuss our experiences from extending JastAddJ to support Java 7. In particular, we discuss how the Try-With-Resources statement and the Diamond operator could be implemented, and how efficient the resulting Java 7 compiler is regarding code size, compilation time, and memory usage.},
  booktitle = {Proceedings of the 2013 International Conference on Principles and Practices of Programming on the Java Platform: Virtual Machines, Languages, and Tools},
  pages     = {147–152},
  numpages  = {6},
  keywords  = {compiler design, attribute grammars, Java},
  location  = {Stuttgart, Germany},
  series    = {PPPJ '13}
}
@article{hedin2000rags,
	title        = {Reference Attributed Grammars},
	author       = {G{\"{o}}rel Hedin},
	year         = 2000,
	journal      = {Informatica (Slovenia)},
	volume       = 24,
	number       = 3,
	biburl       = {https://dblp.org/rec/journals/informaticaSI/Hedin00.bib}
}
@article{a42d66bd599e4d45b783a5de8b652497,
	title        = {Circular Reference Attributed Grammars - their Evaluation and Applications},
	author       = {Eva Magnusson and G{\"o}rel Hedin},
	year         = 2007,
	journal      = {Science of Computer Programming},
	publisher    = {Elsevier},
	volume       = 68,
	number       = 1,
	pages        = {21--37},
	doi          = {10.1016/j.scico.2005.06.005},
	issn         = {0167-6423},
	abstract     = {This paper presents a combination of Reference Attributed Grammars (RAGs) and Circular Attribute Grammars (CAGs). While RAGs allow the direct and easy specification of non-locally dependent information, CAGs allow iterative fixed-point computations to be expressed directly using recursive (circular) equations. We demonstrate how the combined formalism, Circular Reference Attributed Grammars (CRAGs), can take advantage of both these strengths, making it possible to express solutions to many problems in an easy way. We exemplify with the specification and computation of the nullable, first, and follow sets used in parser construction, a problem which is highly recursive and normally programmed by hand using an iterative algorithm. We also present a general demand-driven evaluation algorithm for CRAGs and some optimizations of it. The approach has been implemented and experimental results include computations on a series of grammars including that of Java 1.2. We also revisit some of the classical examples of CAGs and show how their solutions are facilitated by CRAGs.},
	keywords     = {fixed-point computations, Attribute grammars, Circular grammars},
	language     = {English}
}
@article{hedin2003jastadd,
	title        = {JastAdd—an aspect-oriented compiler construction system},
	author       = {Hedin, G{\"o}rel and Magnusson, Eva},
	year         = 2003,
	journal      = {Science of Computer Programming},
	publisher    = {Elsevier},
	volume       = 47,
	number       = 1,
	pages        = {37--58}
}
@article{magnusson2007circular,
	title        = {Circular reference attributed grammars—their evaluation and applications},
	author       = {Magnusson, Eva and Hedin, G{\"o}rel},
	year         = 2007,
	journal      = {Science of Computer Programming},
	publisher    = {Elsevier},
	volume       = 68,
	number       = 1,
	pages        = {21--37}
}
@inproceedings{magnusson2007extending,
	title        = {Extending Attribute Grammars with Collection Attributes--Evaluation and Applications},
	author       = {Magnusson, Eva and Ekman, Torbjorn and Hedin, Gorel},
	year         = 2007,
	booktitle    = {Seventh IEEE International Working Conference on Source Code Analysis and Manipulation (SCAM 2007)},
	pages        = {69--80},
	organization = {IEEE}
}
@article{choi1999efficient,
	title        = {Efficient and precise modeling of exceptions for the analysis of Java programs},
	author       = {Choi, Jong-Deok and Grove, David and Hind, Michael and Sarkar, Vivek},
	year         = 1999,
	journal      = {ACM SIGSOFT Software Engineering Notes},
	publisher    = {ACM New York, NY, USA},
	volume       = 24,
	number       = 5,
	pages        = {21--31}
}
@article{amighi2016provably,
	title        = {Provably correct control flow graphs from Java bytecode programs with exceptions},
	author       = {Amighi, Afshin and de Carvalho Gomes, Pedro and Gurov, Dilian and Huisman, Marieke},
	year         = 2016,
	journal      = {International journal on software tools for technology transfer},
	publisher    = {Springer},
	volume       = 18,
	number       = 6,
	pages        = {653--684}
}
@inproceedings{jo2004constructing,
	title        = {Constructing control flow graph for java by decoupling exception flow from normal flow},
	author       = {Jo, Jang-Wu and Chang, Byeong-Mo},
	year         = 2004,
	booktitle    = {International Conference on Computational Science and Its Applications},
	pages        = {106--113},
	organization = {Springer}
}
@inproceedings{helm2020modular,
	title        = {Modular collaborative program analysis in OPAL},
	author       = {Helm, Dominik and K{\"u}bler, Florian and Reif, Michael and Eichberg, Michael and Mezini, Mira},
	year         = 2020,
	booktitle    = {Proceedings of the 28th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
	pages        = {184--196}
}
@phdthesis{szaboincrementalizing,
	title        = {Incrementalizing Static Analyses in Datalog},
	author       = {Szab{\'o}, Tam{\'a}s},
	school       = {Johannes Gutenberg-Universit{\"a}t Mainz}
}
@inproceedings{fors2020patterns,
	title        = {Principles and patterns of JastAdd-style reference attribute grammars},
	author       = {Niklas Fors and Emma S{\"{o}}derberg and G{\"{o}}rel Hedin},
	year         = 2020,
	booktitle    = {Proceedings of the 13th {ACM} {SIGPLAN} International Conference on Software Language Engineering, {SLE} 2020, Virtual Event, USA, November 16-17, 2020},
	publisher    = {{ACM}},
	pages        = {86--100},
	doi          = {10.1145/3426425.3426934},
	url          = {https://doi.org/10.1145/3426425.3426934},
	editor       = {Ralf L{\"{a}}mmel and Laurence Tratt and Juan de Lara}
}
@inproceedings{cousot1977ai,
	title        = {Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints},
	author       = {Cousot, Patrick and Cousot, Radhia},
	year         = 1977,
	booktitle    = {Proceedings of the 4th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages},
	location     = {Los Angeles, California},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {POPL '77},
	pages        = {238--252},
	doi          = {10.1145/512950.512973},
	isbn         = 9781450373500,
	url          = {https://doi.org/10.1145/512950.512973},
	abstract     = {A program denotes computations in some universe of objects. Abstract interpretation of programs consists in using that denotation to describe computations in another universe of abstract objects, so that the results of abstract execution give some information on the actual computations. An intuitive example (which we borrow from Sintzoff [72]) is the rule of signs. The text -1515 * 17 may be understood to denote computations on the abstract universe {(+), (-), (±)} where the semantics of arithmetic operators is defined by the rule of signs. The abstract execution -1515 * 17 → -(+) * (+) → (-) * (+) → (-), proves that -1515 * 17 is a negative number. Abstract interpretation is concerned by a particular underlying structure of the usual universe of computations (the sign, in our example). It gives a summary of some facets of the actual executions of a program. In general this summary is simple to obtain but inaccurate (e.g. -1515 + 17 → -(+) + (+) → (-) + (+) → (±)). Despite its fundamentally incomplete results abstract interpretation allows the programmer or the compiler to answer questions which do not need full knowledge of program executions or which tolerate an imprecise answer, (e.g. partial correctness proofs of programs ignoring the termination problems, type checking, program optimizations which are not carried in the absence of certainty about their feasibility, …).},
	numpages     = 15
}
@article{vanwyk2010silver,
	title        = {Silver: An extensible attribute grammar system},
	author       = {Eric {Van Wyk} and Derek Bodin and Jimin Gao and Lijesh Krishnan},
	year         = 2010,
	journal      = {Science of Computer Programming},
	volume       = 75,
	number       = 1,
	pages        = {39--54},
	doi          = {https://doi.org/10.1016/j.scico.2009.07.004},
	issn         = {0167-6423},
	url          = {https://www.sciencedirect.com/science/article/pii/S0167642309001099},
	note         = {Special Issue on ETAPS 2006 and 2007 Workshops on Language Descriptions, Tools, and Applications (LDTA ’06 and ’07)},
	keywords     = {Extensible languages, Extensible compilers, Attribute grammars, Forwarding, Silver attribute grammar system},
	abstract     = {Attribute grammar specification languages, like many domain-specific languages, offer significant advantages to their users, such as high-level declarative constructs and domain-specific analyses. Despite these advantages, attribute grammars are often not adopted to the degree that their proponents envision. One practical obstacle to their adoption is a perceived lack of both domain-specific and general purpose language features needed to address the many different aspects of a problem. Here we describe Silver, an extensible attribute grammar specification system, and show how it can be extended with general purpose features such as pattern matching and domain-specific features such as collection attributes and constructs for supporting data-flow analysis of imperative programs. The result is an attribute grammar specification language with a rich set of language features. Silver is implemented in itself by a Silver attribute grammar and utilizes forwarding to implement the extensions in a cost-effective manner.}
}
@article{vanwyk2007flow,
	title        = {Using verified data-flow analysis-based optimizations in attribute grammars},
	author       = {Van Wyk, Eric and Krishnan, Lijesh},
	year         = 2007,
	journal      = {Electronic Notes in Theoretical Computer Science},
	publisher    = {Elsevier},
	volume       = 176,
	number       = 3,
	pages        = {109--122}
}
@inproceedings{dura2019metadl,
	title        = {MetaDL: Analysing Datalog in Datalog},
	author       = {Dura, Alexandru and Balldin, Hampus and Reichenbach, Christoph},
	year         = 2019,
	booktitle    = {Proceedings of the 8th ACM SIGPLAN International Workshop on State Of the Art in Program Analysis},
	pages        = {38--43},
	organization = {ACM}
}
@inproceedings{deroover2011soul,
	title        = {The SOUL Tool Suite for Querying Programs in Symbiosis with Eclipse},
	author       = {De Roover, Coen and Noguera, Carlos and Kellens, Andy and Jonckers, Vivane},
	year         = 2011,
	booktitle    = {Proceedings of the 9th International Conference on Principles and Practice of Programming in Java},
	location     = {Kongens Lyngby, Denmark},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {PPPJ '11},
	pages        = {71--80},
	isbn         = 9781450309356,
	url          = {https://doi.org/10.1145/2093157.2093168},
	numpages     = 10,
	keywords     = {logic programming, program analysis, integrated development environments, program queries, software engineering tools}
}
@article{madsen2016datalog,
	title        = {From Datalog to flix: a declarative language for fixed points on lattices},
	author       = {Madsen, Magnus and Yee, Ming-Ho and Lhot{\'a}k, Ond{\v{r}}ej},
	year         = 2016,
	journal      = {ACM SIGPLAN Notices},
	publisher    = {ACM New York, NY, USA},
	volume       = 51,
	number       = 6,
	pages        = {194--208}
}
@article{madsen2020fixpoints,
	title        = {Fixpoints for the masses: programming with first-class Datalog constraints},
	author       = {Madsen, Magnus and Lhot{\'a}k, Ond{\v{r}}ej},
	year         = 2020,
	journal      = {Proceedings of the ACM on Programming Languages},
	publisher    = {ACM New York, NY, USA},
	volume       = 4,
	number       = {OOPSLA},
	pages        = {1--28}
}
@article{smits2020flowspec,
	title        = {FlowSpec: A declarative specification language for intra-procedural flow-Sensitive data-flow analysis},
	author       = {Jeff Smits and Guido Wachsmuth and Eelco Visser},
	year         = 2020,
	journal      = {Journal of Computer Languages},
	volume       = 57,
	pages        = 100924,
	doi          = {https://doi.org/10.1016/j.cola.2019.100924},
	issn         = {2590-1184},
	url          = {https://www.sciencedirect.com/science/article/pii/S2590118419300474},
	abstract     = {Data-flow analysis is the static analysis of programs to estimate their approximate run-time behavior or approximate intermediate run-time values. It is an integral part of modern language specifications and compilers. In the specification of static semantics of programming languages, the concept of data-flow allows the description of well-formedness such as definite assignment of a local variable before its first use. In the implementation of compiler back-ends, data-flow analyses inform optimizations. Data-flow analysis has an established theoretical foundation. What lags behind is implementations of data-flow analysis in compilers, which are usually ad-hoc. This makes such implementations difficult to extend and maintain. In previous work researchers have proposed higher-level formalisms suitable for whole-program analysis in a separate tool, incremental analysis within editors, or bound to a specific intermediate representation. In this paper, we present FlowSpec, an executable formalism for specification of data-flow analysis. FlowSpec is a domain-specific language that enables direct and concise specification of data-flow analysis for programming languages, designed to express flow-sensitive, intra-procedural analyses. We define the formal semantics of FlowSpec in terms of monotone frameworks. We describe the design of FlowSpec using examples of standard analyses. We also include a description of our implementation of FlowSpec. In a case study we evaluate FlowSpec with the static analyses for Green-Marl, a domain-specific programming language for graph analytics.}
}
@article{lerner2005automated,
	title        = {Automated soundness proofs for dataflow analyses and transformations via local rules},
	author       = {Lerner, Sorin and Millstein, Todd and Rice, Erika and Chambers, Craig},
	year         = 2005,
	journal      = {ACM SIGPLAN Notices},
	publisher    = {ACM New York, NY, USA},
	volume       = 40,
	number       = 1,
	pages        = {364--377}
}
@inproceedings{deroover2011soulsummary,
	title        = {A Logic Meta-Programming Foundation for Example-Driven Pattern Detection in Object-Oriented Programs},
	author       = {{De Roover}, Coen},
	year         = 2011,
	booktitle    = {Proceedings of the 27th IEEE International Conference on Software Maintenance (ICSM 2011)},
	series       = {Proceedings of the 27th IEEE International Conference on Software Maintenance (ICSM 2011)},
	isbn         = {978-1-4577-0663-9},
	abstract     = {This paper summarizes the doctoral dissertation in which we introduced an example-driven approach to pattern detection. This approach enables specifying pattern characteristics in a familiar language: through a code excerpt that corresponds to their prototypical implementation. Such excerpts are matched against the program under investigation according to various matching strategies that vary in leniency. Each match is quantified by the extent to which it exhibits the exemplified characteristics. The smaller this extent, the more likely the match is a false positive --thus establishing a ranking which facilitates assessing a large amount of matches. Unique to the matching process is that it incorporates whole-program analyses in its comparison of individual program elements. This way, we are able to recall implicit implementation variants (i.e., those implied by the semantics of the programming language) of a pattern of which only the prototypical implementation has been exemplified.},
	keywords     = {logic meta programming, pattern detection, program querying, static analysis},
	language     = {English}
}
@inproceedings{bravenboer09doop,
	title        = {Strictly declarative specification of sophisticated points-to analyses},
	author       = {Bravenboer, Martin and Smaragdakis, Yannis},
	year         = 2009,
	booktitle    = {Proceedings of OOPSLA '09},
	location     = {Orlando, Florida, USA},
	publisher    = {ACM},
	address      = {New York, NY, USA},
	pages        = {243--262},
	isbn         = {978-1-60558-766-0},
	abstract     = {We present the DOOP framework for points-to analysis of Java programs. DOOP builds on the idea of specifying pointer analysis algorithms declaratively, using Datalog: a logic-based language for defining (recursive) relations. We carry the declarative approach further than past work by describing the full end-to-end analysis in Datalog and optimizing aggressively using a novel technique specifically targeting highly recursive Datalog programs.},
	citeulike-article-id = 6210299,
	citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1640089.1640108},
	citeulike-linkout-1 = {http://dx.doi.org/10.1145/1640089.1640108},
	keywords     = {forward-chaining, logic-programming, program-analysis, semi-naive-evaluation},
	posted-at    = {2009-11-25 15:19:11},
	priority     = {0}
}
@inproceedings{kildall1973dataflow,
	title        = {A Unified Approach to Global Program Optimization},
	author       = {Kildall, Gary A.},
	year         = 1973,
	booktitle    = {Proceedings of the 1st Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages},
	location     = {Boston, Massachusetts},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {POPL '73},
	pages        = {194–206},
	doi          = {10.1145/512927.512945},
	isbn         = 9781450373494,
	url          = {https://doi.org/10.1145/512927.512945},
	abstract     = {A technique is presented for global analysis of program structure in order to perform compile time optimization of object code generated for expressions. The global expression optimization presented includes constant propagation, common subexpression elimination, elimination of redundant register load operations, and live expression analysis. A general purpose program flow analysis algorithm is developed which depends upon the existence of an "optimizing function." The algorithm is defined formally using a directed graph model of program flow structure, and is shown to be correct. Several optimizing functions are defined which, when used in conjunction with the flow analysis algorithm, provide the various forms of code optimization. The flow analysis algorithm is sufficiently general that additional functions can easily be defined for other forms of global code optimization.},
	numpages     = 13
}
@inproceedings{bodden2012inter,
	title        = {Inter-procedural data-flow analysis with ifds/ide and soot},
	author       = {Bodden, Eric},
	year         = 2012,
	booktitle    = {Proceedings of the ACM SIGPLAN International Workshop on State of the Art in Java Program analysis},
	pages        = {3--8}
}
@article{sagiv1996ide,
	title        = {Precise interprocedural dataflow analysis with applications to constant propagation},
	author       = {Sagiv, Mooly and Reps, Thomas and Horwitz, Susan},
	year         = 1996,
	journal      = {Theoretical Computer Science},
	publisher    = {Elsevier},
	volume       = 167,
	number       = {1-2},
	pages        = {131--170}
}
@inproceedings{vallee-rai10soot,
	title        = {Soot: A Java Bytecode Optimization Framework},
	author       = {Vall{\'e}e-Rai, Raja and Co, Phong and Gagnon, Etienne and Hendren, Laurie and Lam, Patrick and Sundaresan, Vijay},
	year         = 2010,
	booktitle    = {CASCON First Decade High Impact Papers},
	location     = {Toronto, Ontario, Canada},
	publisher    = {IBM Corp.},
	address      = {Riverton, NJ, USA},
	series       = {CASCON '10},
	pages        = {214--224},
	doi          = {10.1145/1925805.1925818},
	url          = {http://dx.doi.org/10.1145/1925805.1925818},
	numpages     = 11,
	acmid        = 1925818
}
@article{spaeth2019pda,
	title        = {Context-, Flow-, and Field-Sensitive Data-Flow Analysis Using Synchronized Pushdown Systems},
	author       = {Sp\"{a}th, Johannes and Ali, Karim and Bodden, Eric},
	year         = 2019,
	month        = jan,
	journal      = {Proc. ACM Program. Lang.},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 3,
	number       = {POPL},
	doi          = {10.1145/3290361},
	url          = {https://doi.org/10.1145/3290361},
	issue_date   = {January 2019},
	abstract     = {Precise static analyses are context-, field- and flow-sensitive. Context- and field-sensitivity are both expressible as context-free language (CFL) reachability problems. Solving both CFL problems along the same data-flow path is undecidable, which is why most flow-sensitive data-flow analyses over-approximate field-sensitivity through k-limited access-path, or through access graphs. Unfortunately, as our experience and this paper show, both representations do not scale very well when used to analyze programs with recursive data structures. Any single CFL-reachability problem is efficiently solvable, by means of a pushdown system. This work thus introduces the concept of synchronized pushdown systems (SPDS). SPDS encode both procedure calls/returns and field stores/loads as separate but “synchronized” CFL reachability problems. An SPDS solves both individual problems precisely, and approximation occurs only in corner cases that are apparently rare in practice: at statements where both problems are satisfied but not along the same data-flow path. SPDS are also efficient: formal complexity analysis shows that SPDS shift the complexity from |F|3k under k-limiting to |S||F|2, where F is the set of fields and S the set of statements involved in a data-flow. Our evaluation using DaCapo shows this shift to pay off in practice: SPDS are almost as efficient as k-limiting with k=1 although their precision equals k=∞. For a typestate analysis SPDS accelerate the analysis up to 83\texttimes{} for data-flows of objects that involve many field accesses but span rather few methods. We conclude that SPDS can provide high precision and further improve scalability, in particularly when used in analyses that expose rather local data flows.},
	articleno    = 48,
	numpages     = 29,
	keywords     = {aliasing, static analysis, access paths, pushdown system, data-flow}
}
@misc{fink2012wala,
	title        = {WALA--The TJ Watson Libraries for Analysis},
	author       = {Fink, Stephen and Dolby, Julian},
	year         = 2012
}
@inproceedings{smaragdakis2010using,
	title        = {Using Datalog for fast and easy program analysis},
	author       = {Smaragdakis, Yannis and Bravenboer, Martin},
	year         = 2010,
	booktitle    = {International Datalog 2.0 Workshop},
	pages        = {245--251},
	organization = {Springer}
}
@inproceedings{lhotak03scaling,
	title        = {Scaling Java points-to analysis using Spark},
	author       = {Lhot{\'a}k, Ond{\v{r}}ej and Hendren, Laurie},
	year         = 2003,
	booktitle    = {International Conference on Compiler Construction},
	pages        = {153--169},
	organization = {Springer}
}
@article{szabo2018inca,
	title        = {Incrementalizing Lattice-Based Program Analyses in Datalog},
	author       = {Szab\'{o}, Tam\'{a}s and Bergmann, G\'{a}bor and Erdweg, Sebastian and Voelter, Markus},
	year         = 2018,
	month        = oct,
	journal      = {Proc. ACM Program. Lang.},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 2,
	number       = {OOPSLA},
	doi          = {10.1145/3276509},
	url          = {https://doi.org/10.1145/3276509},
	issue_date   = {November 2018},
	abstract     = {Program analyses detect errors in code, but when code changes frequently as in an IDE, repeated re-analysis from-scratch is unnecessary: It leads to poor performance unless we give up on precision and recall. Incremental program analysis promises to deliver fast feedback without giving up on precision or recall by deriving a new analysis result from the previous one. However, Datalog and other existing frameworks for incremental program analysis are limited in expressive power: They only support the powerset lattice as representation of analysis results, whereas many practically relevant analyses require custom lattices and aggregation over lattice values. To this end, we present a novel algorithm called DRedL that supports incremental maintenance of recursive lattice-value aggregation in Datalog. The key insight of DRedL is to dynamically recognize increasing replacements of old lattice values by new ones, which allows us to avoid the expensive deletion of the old value. We integrate DRedL into the analysis framework IncA and use IncA to realize incremental implementations of strong-update points-to analysis and string analysis for Java. As our performance evaluation demonstrates, both analyses react to code changes within milliseconds.},
	articleno    = 139,
	numpages     = 29,
	keywords     = {Incremental Computing, Static Analysis, Domain-Specific Language, Lattice, Datalog, Language Workbench}
}
@inproceedings{lawall10coccinelle,
	title        = {{Finding Error Handling Bugs in OpenSSL Using Coccinelle}},
	author       = {Lawall, Julia and Laurie, Ben and Hansen, Ren{\'e} Rydhof and Palix, Nicolas and Muller, Gilles},
	year         = 2010,
	month        = Apr,
	booktitle    = {{European Dependable Computing Conference}},
	address      = {Valencia, Spain},
	pages        = {191--196},
	doi          = {10.1109/EDCC.2010.31},
	url          = {https://hal.archives-ouvertes.fr/hal-00940375},
	keywords     = {Software quality ; Software evolution ; Static code analysis},
	hal_id       = {hal-00940375},
	hal_version  = {v1}
}
@inproceedings{falconer2007deepweaver,
	title        = {A Declarative Framework for Analysis and Optimization},
	author       = {Falconer, Henry and Kelly, Paul H. J. and Ingram, David M. and Mellor, Michael R. and Field, Tony and Beckmann, Olav},
	year         = 2007,
	booktitle    = {Compiler Construction},
	publisher    = {Springer Berlin Heidelberg},
	address      = {Berlin, Heidelberg},
	pages        = {218--232},
	isbn         = {978-3-540-71229-9},
	editor       = {Krishnamurthi, Shriram and Odersky, Martin},
	abstract     = {DeepWeaver-1 is a tool supporting cross-cutting program analysis and transformation components, called ``weaves''. Like an aspect, a DeepWeaver weave consists of a query part, and a part which may modify code. DeepWeaver's query language is based on Prolog, and provides access to data-flow and control-flow reachability analyses. DeepWeaver provides a declarative way to access the internal structure of methods, and supports cross-cutting weaves which operate on code blocks from different parts of the codebase simultaneously. DeepWeaver operates at the level of bytecode, but offers predicates to extract structured control flow constructs. This paper motivates the design, and demonstrates some of its power, using a sequence of examples including performance profiling and domain-specific performance optimisations for database access and remote method invocation.}
}
@book{copeland2005pmd,
	title        = {PMD applied},
	author       = {Copeland, Tom},
	year         = 2005,
	publisher    = {Centennial Books Arexandria, Va, USA},
	volume       = 10
}
@inproceedings{visser2002concretesyntax,
	title        = {Meta-Programming with Concrete Object Syntax},
	author       = {Visser, Eelco},
	year         = 2002,
	booktitle    = {Proceedings of the 1st ACM SIGPLAN/SIGSOFT Conference on Generative Programming and Component Engineering},
	publisher    = {Springer-Verlag},
	address      = {Berlin, Heidelberg},
	series       = {GPCE '02},
	pages        = {299–315},
	isbn         = 3540442847,
	abstract     = {Meta programs manipulate structured representations, i.e., abstract syntax trees, of programs. The conceptual distance between the concrete syntax meta-programmers use to reason about programs and the notation for abstract syntax manipulation provided by general purpose (meta-) programming languages is too great for many applications. In this paper it is shown how the syntax definition formalism SDF can be employed to fit any meta-programming language with concrete syntax notation for composing and analyzing object programs. As a case study, the addition of concrete syntax to the program transformation language Stratego is presented. The approach is then generalized to arbitrary meta-languages.},
	numpages     = 17
}
@article{visser04stratego,
	title        = {{P}rogram {T}ransformation with {S}tratego/{XT}: {R}ules, {S}trategies, {T}ools, and {S}ystems in {Stratego/XT} 0.9},
	author       = {E. Visser},
	year         = 2004,
	month        = {June},
	journal      = {Lecture Notes in Computer Science},
	volume       = 3016,
	pages        = {216--238},
	url          = {citeseer.ist.psu.edu/article/visser04program.html},
	editor       = {C. Lengauer et al.}
}
@inproceedings{reps1995ifds,
	title        = {Precise interprocedural dataflow analysis via graph reachability},
	author       = {Reps, Thomas and Horwitz, Susan and Sagiv, Mooly},
	year         = 1995,
	booktitle    = {Proceedings of the 22nd ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
	pages        = {49--61}
}
@inproceedings{reichenbach2021ticks,
	title        = {{Software Ticks Need No Specifications}},
	author       = {Reichenbach, Christoph},
	year         = 2021,
	booktitle    = {Proceedings of the 43rd International Conference on Software Engineering: New Ideas and Emerging Results Track},
	location     = {Virtual}
}
@inproceedings{DaCapo:paper,
	title        = {The {DaCapo} Benchmarks: {J}ava Benchmarking Development and Analysis},
	author       = {Blackburn, S. M. and Garner, R. and Hoffman, C. and Khan, A. M. and McKinley, K. S. and Bentzur, R. and Diwan, A. and Feinberg, D. and Frampton, D. and Guyer, S. Z. and Hirzel, M. and Hosking, A. and Jump, M. and Lee, H. and Moss, J. E. B. and Phansalkar, A. and Stefanovi\'{c}, D. and {VanDrunen}, T. and von~Dincklage, D. and Wiedermann, B.},
	year         = 2006,
	month        = oct,
	booktitle    = {OOPSLA '06: Proceedings of the 21st annual ACM SIGPLAN conference on Object-Oriented Programming, Systems, Languages, and Applications},
	location     = {Portland, OR, USA},
	publisher    = {ACM Press},
	address      = {New York, NY, USA},
	pages        = {169--190},
	doi          = {http://doi.acm.org/10.1145/1167473.1167488}
}
@phdthesis{oqvist2018contributions,
	title        = {Contributions to Declarative Implementation of Static Program Analysis},
	author       = {{\"O}qvist, Jesper},
	year         = 2018,
	school       = {Lund University}
}
@inproceedings{jourdan84,
	title        = {An Optimal-time Recursive Evaluator for Attribute Grammars},
	author       = {Martin Jourdan},
	year         = 1984,
	booktitle    = {International Symposium on Programming, 6th Colloquium, Toulouse, France, April 17-19, 1984, Proceedings},
	publisher    = {Springer},
	series       = {Lecture Notes in Computer Science},
	volume       = 167,
	pages        = {167--178},
	doi          = {10.1007/3-540-12925-1\_37},
	url          = {https://doi.org/10.1007/3-540-12925-1\_37},
	editor       = {Manfred Paul and Bernard Robinet},
	timestamp    = {Tue, 14 May 2019 10:00:35 +0200},
	biburl       = {https://dblp.org/rec/conf/programm/Jourdan84.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{piskachev2021secucheck,
	title        = {SecuCheck: Engineering configurable taint analysis for software developers},
	author       = {Piskachev, Goran and Krishnamurthy, Ranjith and Bodden, Eric},
	year         = 2021,
	booktitle    = {2021 IEEE 21st International Working Conference on Source Code Analysis and Manipulation (SCAM)},
	pages        = {24--29},
	organization = {IEEE}
}
@article{flowdroid,
	title        = {FlowDroid: Precise Context, Flow, Field, Object-Sensitive and Lifecycle-Aware Taint Analysis for Android Apps},
	author       = {Arzt, Steven and Rasthofer, Siegfried and Fritz, Christian and Bodden, Eric and Bartel, Alexandre and Klein, Jacques and Le Traon, Yves and Octeau, Damien and McDaniel, Patrick},
	year         = 2014,
	month        = {jun},
	journal      = {SIGPLAN Not.},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 49,
	number       = 6,
	pages        = {259–269},
	doi          = {10.1145/2666356.2594299},
	issn         = {0362-1340},
	url          = {https://doi.org/10.1145/2666356.2594299},
	issue_date   = {June 2014},
	abstract     = {Today's smartphones are a ubiquitous source of private and confidential data. At the same time, smartphone users are plagued by carelessly programmed apps that leak important data by accident, and by malicious apps that exploit their given privileges to copy such data intentionally. While existing static taint-analysis approaches have the potential of detecting such data leaks ahead of time, all approaches for Android use a number of coarse-grain approximations that can yield high numbers of missed leaks and false alarms.In this work we thus present FlowDroid, a novel and highly precise static taint analysis for Android applications. A precise model of Android's lifecycle allows the analysis to properly handle callbacks invoked by the Android framework, while context, flow, field and object-sensitivity allows the analysis to reduce the number of false alarms. Novel on-demand algorithms help FlowDroid maintain high efficiency and precision at the same time.We also propose DroidBench, an open test suite for evaluating the effectiveness and accuracy of taint-analysis tools specifically for Android apps. As we show through a set of experiments using SecuriBench Micro, DroidBench, and a set of well-known Android test applications, FlowDroid finds a very high fraction of data leaks while keeping the rate of false positives low. On DroidBench, FlowDroid achieves 93% recall and 86% precision, greatly outperforming the commercial tools IBM AppScan Source and Fortify SCA. FlowDroid successfully finds leaks in a subset of 500 apps from Google Play and about 1,000 malware apps from the VirusShare project.},
	numpages     = 11
}
@inproceedings{cousot2005astree,
	title        = {The ASTR{\'E}E analyzer},
	author       = {Cousot, Patrick and Cousot, Radhia and Feret, J{\'e}r{\^o}me and Mauborgne, Laurent and Min{\'e}, Antoine and Monniaux, David and Rival, Xavier},
	year         = 2005,
	booktitle    = {European Symposium on Programming},
	pages        = {21--30},
	organization = {Springer}
}
@inbook{Blanchet2002,
	title        = {Design and Implementation of a Special-Purpose Static Program Analyzer for Safety-Critical Real-Time Embedded Software},
	author       = {Blanchet, Bruno and Cousot, Patrick and Cousot, Radhia and Feret, J{\'e}r{\^o}me and Mauborgne, Laurent and Min{\'e}, Antoine and Monniaux, David and Rival, Xavier},
	year         = 2002,
	booktitle    = {The Essence of Computation: Complexity, Analysis, Transformation},
	publisher    = {Springer Berlin Heidelberg},
	address      = {Berlin, Heidelberg},
	pages        = {85--108},
	doi          = {10.1007/3-540-36377-7_5},
	isbn         = {978-3-540-36377-4},
	url          = {https://doi.org/10.1007/3-540-36377-7_5},
	editor       = {Mogensen, Torben {\AE}. and Schmidt, David A. and Sudborough, I. Hal},
	abstract     = {We report on a successful preliminary experience in the design and implementation of a special-purpose Abstract Interpretation based static program analyzer for the verification of safety critical embedded real-time software. The analyzer is both precise (zero false alarm in the considered experiment) and efficient (less than one minute of analysis for 10,000 lines of code). Even if it is based on a simple interval analysis, many features have been added to obtain the desired precision: expansion of small arrays, widening with several thresholds, loop unrolling, trace partitioning, relations between loop counters and other variables. The efficiency of the tool mainly comes from a clever representation of abstract environments based on balanced binary search trees.}
}
@article{rice1953classes,
	title        = {Classes of recursively enumerable sets and their decision problems},
	author       = {Rice, Henry Gordon},
	year         = 1953,
	journal      = {Transactions of the American Mathematical society},
	publisher    = {JSTOR},
	volume       = 74,
	number       = 2,
	pages        = {358--366}
}
@article{SLOANE2010205,
	title        = {A Pure Object-Oriented Embedding of Attribute Grammars},
	author       = {Anthony M. Sloane and Lennart C.L. Kats and Eelco Visser},
	year         = 2010,
	journal      = {Electronic Notes in Theoretical Computer Science},
	volume       = 253,
	number       = 7,
	pages        = {205--219},
	doi          = {https://doi.org/10.1016/j.entcs.2010.08.043},
	issn         = {1571-0661},
	url          = {https://www.sciencedirect.com/science/article/pii/S1571066110001222},
	note         = {Proceedings of the Ninth Workshop on Language Descriptions Tools and Applications (LDTA 2009)},
	keywords     = {language processing, compilers, domain-specific languages},
	abstract     = {Attribute grammars are a powerful specification paradigm for many language processing tasks, particularly semantic analysis of programming languages. Recent attribute grammar systems use dynamic scheduling algorithms to evaluate attributes by need. In this paper, we show how to remove the need for a generator, by embedding a dynamic approach in a modern, object-oriented programming language to implement a small, lightweight attribute grammar library. The Kiama attribution library has similar features to current generators, including cached, uncached, circular, higher-order and parameterised attributes, and implements new techniques for dynamic extension and variation of attribute equations. We use the Scala programming language because of its combination of object-oriented and functional features, support for domain-specific notations and emphasis on scalability. Unlike generators with specialised notation, Kiama attribute grammars use standard Scala notations such as pattern-matching functions for equations and mixins for composition. A performance analysis shows that our approach is practical for realistic language processing.}
}
@article{VANWYK201039,
	title        = {Silver: An extensible attribute grammar system},
	author       = {Eric {Van Wyk} and Derek Bodin and Jimin Gao and Lijesh Krishnan},
	year         = 2010,
	journal      = {Science of Computer Programming},
	volume       = 75,
	number       = 1,
	pages        = {39--54},
	doi          = {https://doi.org/10.1016/j.scico.2009.07.004},
	issn         = {0167-6423},
	url          = {https://www.sciencedirect.com/science/article/pii/S0167642309001099},
	note         = {Special Issue on ETAPS 2006 and 2007 Workshops on Language Descriptions, Tools, and Applications (LDTA ’06 and ’07)},
	keywords     = {Extensible languages, Extensible compilers, Attribute grammars, Forwarding, Silver attribute grammar system},
	abstract     = {Attribute grammar specification languages, like many domain-specific languages, offer significant advantages to their users, such as high-level declarative constructs and domain-specific analyses. Despite these advantages, attribute grammars are often not adopted to the degree that their proponents envision. One practical obstacle to their adoption is a perceived lack of both domain-specific and general purpose language features needed to address the many different aspects of a problem. Here we describe Silver, an extensible attribute grammar specification system, and show how it can be extended with general purpose features such as pattern matching and domain-specific features such as collection attributes and constructs for supporting data-flow analysis of imperative programs. The result is an attribute grammar specification language with a rich set of language features. Silver is implemented in itself by a Silver attribute grammar and utilizes forwarding to implement the extensions in a cost-effective manner.}
}
@misc{rusling1999linux,
	title        = {The linux kernel},
	author       = {Rusling, David A},
	year         = 1999
}
@article{madsen2016flix,
	title={From Datalog to Flix: A Declarative Language for Fixed Points on Lattices},
	author={Madsen, Magnus and Yee, Ming-Ho and Lhot{\'a}k, Ond{\v{r}}ej},
	journal={ACM SIGPLAN Notices},
	volume={51},
	number={6},
	pages={194--208},
	year={2016},
	publisher={ACM New York, NY, USA}
}



@article{madsen2016programming,
	title        = {Programming a Dataflow Analysis in Flix},
	author       = {Madsen, Magnus and Yee, Ming-Ho and Lhot{\'a}k, Ondrej},
	year         = 2016,
	journal      = {Tools for Automatic Program Analysis (TAPAS)}
}
@misc{checkstyle,
	title        = {{Checkstyle}},
	publisher    = {Checkstyle},
	note         = {{Accessed:} 2023-06-21},
	howpublished = {\url{https://checkstyle.org}},
	key          = {Checkstyle}
}
@misc{sonarlint,
	title        = {{SonarLint}},
	publisher    = {SonarSource},
	note         = {{Accessed:} 2023-06-21},
	howpublished = {\url{https://www.sonarlint.org}},
	key          = {SonarLint}
}
@misc{spotbugs,
	title        = {{SpotBugs}},
	publisher    = {SpotBugs},
	note         = {{Accessed:} 2023-02-17},
	howpublished = {\url{https://spotbugs.github.io/}},
	key          = {SpotBugs}
}
@misc{findbugs,
	title        = {{FindBugs}},
	publisher    = {FindBugs},
	note         = {{Accessed:} 2023-02-17},
	howpublished = {\url{http://findbugs.sourceforge.net/}},
	key          = {FindBugs}
}
@article{spoon,
	title        = {SPOON: A library for implementing analyses and transformations of Java source code},
	author       = {Pawlak, Renaud and Monperrus, Martin and Petitprez, Nicolas and Noguera, Carlos and Seinturier, Lionel},
	year         = 2016,
	journal      = {Software: Practice and Experience},
	volume       = 46,
	number       = 9,
	pages        = {1155--1179},
	doi          = {https://doi.org/10.1002/spe.2346},
	url          = {https://onlinelibrary.wiley.com/doi/abs/10.1002/spe.2346},
	keywords     = {source code analysis, source code transformation, metaprogramming},
	eprint       = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/spe.2346},
	abstract     = {Summary This paper presents SPOON, a library for the analysis and transformation of Java source code. SPOON enables Java developers to write a large range of domain-specific analyses and transformations in an easy and concise manner. SPOON analyses and transformations are written in plain Java. With SPOON, developers do not need to dive into parsing, to hack a compiler infrastructure, or to master a new formalism. Copyright © 2015 John Wiley \& Sons, Ltd.}
}
@article{CREMERS197586,
	title        = {Context-free grammar forms},
	author       = {Armin Cremers and Seymour Ginsburg},
	year         = 1975,
	journal      = {Journal of Computer and System Sciences},
	volume       = 11,
	number       = 1,
	pages        = {86--117},
	doi          = {https://doi.org/10.1016/S0022-0000(75)80051-1},
	issn         = {0022-0000},
	url          = {https://www.sciencedirect.com/science/article/pii/S0022000075800511},
	abstract     = {In an attempt to provide a unified theory of grammars, a model is introduced which has two components. The first is a “grammar form,” which provides the general structure of the productions in the grammars to be defined. The second is an “interpretation”, which yields a specific grammar. By considering all interpretations, a family of grammars, intimately related to that of the grammar form, is obtained. Many of the well-known families of grammars occur as special instances. Attention is focused on the situation when the productions in the grammar form are context free. Necessary and sufficient conditions on a context-free grammar form are given in order for it, to yield, respectively, exactly the finite languages, the regular sets, the linear context-free languages, and all the context-free languages. Each context-free grammar form can be replaced by another, yielding the same family of languages, in which the underlying grammar is sequential. Of special interest to language theory is the fact the family of languages obtained from each context-free grammar form is a full principal semi-AFL.}
}
@article{Kam1977,
	title        = {Monotone data flow analysis frameworks},
	author       = {Kam, J.B. and Ullman, J.D.},
	year         = 1977,
	journal      = {Acta Informatica},
	volume       = 7,
	pages        = {305--317},
	doi          = {https://doi.org/10.1007/BF00290339}
}
@book{Donnellan1968,
	title        = {Lattice Theory},
	author       = {Donnellan, Thomas},
	year         = 1968,
	publisher    = {Pergamon}
}
@book{Birkhoff1967,
	title        = {Introduction to Lattices and Order},
	author       = {Birkhoff, Garrett},
	year         = 1967,
	publisher    = {Cambridge University Press}
}
@article{Knaster1929,
	title        = {A fixed point theorem for monotone mappings},
	author       = {Knaster, Bronislaw and Tarski, Alfred},
	year         = 1929,
	journal      = {Fundamenta Mathematicae},
	volume       = 14,
	pages        = {124--134}
}
@article{Hesse1874,
	title        = {Beiträge zur Begründung der projektiven Geometrie},
	author       = {Hesse, Otto},
	year         = 1874,
	journal      = {Mathematische Annalen},
	volume       = 8,
	pages        = {476--486}
}


@article{tarski1955lattice,
author = {Alfred Tarski},
title = {{A lattice-theoretical fixpoint theorem and its applications.}},
volume = {5},
journal = {Pacific Journal of Mathematics},
number = {2},
publisher = {Pacific Journal of Mathematics},
pages = {285 -- 309},
abstract = {},
year = {1955},
}


@inproceedings{piskachev2022far,
	title        = {How far are German companies in improving security through static program analysis tools?},
	author       = {Piskachev, Goran and Dziwok, Stefan and Koch, Thorsten and Merschjohann, Sven and Bodden, Eric},
	year         = 2022,
	booktitle    = {2022 IEEE Secure Development Conference (SecDev)},
	pages        = {7--15},
	organization = {IEEE}
}
@book{Nielson2010Principles,
	title        = {Principles of Program Analysis},
	author       = {Nielson, Flemming and Nielson, Hanne R. and Hankin, Chris},
	year         = 2010,
	publisher    = {Springer Publishing Company, Incorporated},
	isbn         = 3642084745,
	abstract     = {Program analysis utilizes static techniques for computing reliable information about the dynamic behavior of programs. Applications include compilers (for code improvement), software validation (for detecting errors) and transformations between data representation (for solving problems such as Y2K). This book is unique in providing an overview of the four major approaches to program analysis: data flow analysis, constraint-based analysis, abstract interpretation, and type and effect systems. The presentation illustrates the extensive similarities between the approaches, helping readers to choose the best one to utilize.}
}
@inproceedings{Bagnara2003Widening,
	title        = {Widening Operators for Powerset Domains},
	author       = {Bagnara, Roberto and Hill, Patricia and Zaffanella, Enea},
	year         = 2003,
	month        = 12,
	pages        = {403--433},
	doi          = {10.1007/978-3-540-24622-0_13},
	isbn         = {978-3-540-20803-7}
}


@article{risberg2022property,
  author       = {Anton Risberg Alak{\"{u}}la and
                  G{\"{o}}rel Hedin and
                  Niklas Fors and
                  Adrian Pop},
  title        = {Property probes: Live exploration of program analysis results},
  journal      = {J. Syst. Softw.},
  volume       = {211},
  pages        = {111980},
  year         = {2024},
  url          = {https://doi.org/10.1016/j.jss.2024.111980},
  doi          = {10.1016/J.JSS.2024.111980},
  timestamp    = {Tue, 18 Jun 2024 09:55:53 +0200},
  biburl       = {https://dblp.org/rec/journals/jss/AlakulaHFP24.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}



@misc{Microsoftlsp,
	title        = {Language Server Protocol},
	publisher    = {Microsoft Corporation},
	note         = {{Accessed:} 2023-02-27},
	key          = {Mica},
	howpublished = {\url{https://microsoft.github.io/language-server-protocol/}}
}
@misc{Microsoftvscode,
	title        = {Visual Studio Code},
	publisher    = {Microsoft Corporation},
	note         = {{Accessed:} 2023-02-27},
	key          = {Micb},
	howpublished = {\url{https://code.visualstudio.com/}}
}
@misc{vim,
	title        = {VIM - Vi IMproved},
	author       = {Bram Moolenaar},
	note         = {{Accessed:} 2023-02-27},
	howpublished = {\url{https://www.vim.org/}}
}
@misc{emacs,
	title        = {GNU Emacs},
	author       = {Free Software Foundation},
	note         = {{Accessed:} 2023-02-27},
	howpublished = {\url{https://www.gnu.org/software/emacs/}}
}

@article{DBLP:journals/cacm/Knuth74,
	title        = {{Computer Programming as an Art}},
	author       = {Donald E. Knuth},
	year         = 1974,
	journal      = {Commun. {ACM}},
	volume       = 17,
	number       = 12,
	pages        = {667--673},
	doi          = {10.1145/361604.361612},
	timestamp    = {Tue, 07 Jun 2011 16:50:57 +0200},
	biburl       = {http://dblp.uni-trier.de/rec/bib/journals/cacm/Knuth74},
	bibsource    = {dblp computer science bibliography, http://dblp.org}
}
@article{DBLP:journals/cacm/Dijkstra68a,
	title        = {Letters to the editor: go to statement considered harmful},
	author       = {Edsger W. Dijkstra},
	year         = 1968,
	journal      = {Commun. {ACM}},
	volume       = 11,
	number       = 3,
	pages        = {147--148},
	doi          = {10.1145/362929.362947},
	timestamp    = {Thu, 09 Feb 2006 13:19:49 +0100},
	biburl       = {http://dblp.uni-trier.de/rec/bib/journals/cacm/Dijkstra68a},
	bibsource    = {dblp computer science bibliography, http://dblp.org}
}









@inproceedings{lattner2004llvm,
	title        = {LLVM: A compilation framework for lifelong program analysis \& transformation},
	author       = {Lattner, Chris and Adve, Vikram},
	year         = 2004,
	booktitle    = {International Symposium on Code Generation and Optimization, 2004. CGO 2004.},
	pages        = {75--86},
	organization = {IEEE}
}
@inproceedings{just2014defects4j,
	title        = {{Defects4J: A database of existing faults to enable controlled testing studies for Java programs}},
	author       = {Just, Ren{\'e} and Jalali, Darioush and Ernst, Michael D},
	year         = 2014,
	booktitle    = {Proceedings of the 2014 International Symposium on Software Testing and Analysis},
	pages        = {437--440}
}
@inproceedings{QualitasCorpus,
	title        = {{Qualitas Corpus: A Curated Collection of Java Code for Empirical Studies}},
	author       = {Tempero, Ewan and Anslow, Craig and Dietrich, Jens and Han, Ted and Li, Jing and Lumpe, Markus and Melton, Hayden and Noble, James},
	year         = 2010,
	month        = dec,
	booktitle    = {2010 Asia Pacific Software Engineering Conference (APSEC2010)},
	pages        = {336--345},
	doi          = {http://dx.doi.org/10.1109/APSEC.2010.46}
}
@article{dietrich2017xcorpus,
	title        = {{XCorpus - An executable Corpus of Java Programs}},
	author       = {Jens Dietrich and Henrik Schole and Li Sui and Ewan D. Tempero},
	year         = 2017,
	journal      = {Journal of Object Technology},
	volume       = 16,
	number       = 4,
	pages        = {1:1--24}
}

@inproceedings{riouak2021precise,
	title        = {A Precise Framework for Source-Level Control-Flow Analysis},
	author       = {Riouak, Idriss and Reichenbach, Christoph and Hedin, G{\"o}rel and Fors, Niklas},
	year         = 2021,
	booktitle    = {2021 IEEE 21st International Working Conference on Source Code Analysis and Manipulation (SCAM)},
	pages        = {1--11},
	organization = {IEEE}
}
@article{Spi05g,
	title        = {Tool Writing: A Forgotten Art?},
	author       = {Diomidis Spinellis},
	year         = 2005,
	month        = {July/August},
	journal      = {IEEE Software},
	volume       = 22,
	number       = 4,
	pages        = {9--11},
	doi          = {10.1109/MS.2005.111},
	issn         = {0740-7459},
	url          = {http://www.spinellis.gr/pubs/jrnl/2005-IEEESW-TotT/html/v22n4.html},
	tags         = {sweng}
}
@inproceedings{collectionattributes,
	title        = {Extending Attribute Grammars with Collection Attributes--Evaluation and Applications},
	author       = {Magnusson, Eva and Ekman, Torbjorn and Hedin, Gorel},
	year         = 2007,
	booktitle    = {Seventh IEEE International Working Conference on Source Code Analysis and Manipulation (SCAM 2007)},
	volume       = {},
	number       = {},
	pages        = {69--80},
	doi          = {10.1109/SCAM.2007.13}
}
@article{blackburn2008wake,
	title        = {Wake up and smell the coffee: Evaluation methodology for the 21st century},
	author       = {Blackburn, Stephen M and McKinley, Kathryn S and Garner, Robin and Hoffmann, Chris and Khan, Asjad M and Bentzur, Rotem and Diwan, Amer and Feinberg, Daniel and Frampton, Daniel and Guyer, Samuel Z and others},
	year         = 2008,
	journal      = {Communications of the ACM},
	publisher    = {ACM New York, NY, USA},
	volume       = 51,
	number       = 8,
	pages        = {83--89}
}
@article{costa2019s,
	title        = {What's wrong with my benchmark results? studying bad practices in JMH benchmarks},
	author       = {Costa, Diego and Bezemer, Cor-Paul and Leitner, Philipp and Andrzejak, Artur},
	year         = 2019,
	journal      = {IEEE Transactions on Software Engineering},
	publisher    = {IEEE},
	volume       = 47,
	number       = 7,
	pages        = {1452--1467}
}
@inproceedings{reichenbach2010can,
	title        = {{What can the {GC} compute efficiently?: A language for heap assertions at {GC} time}},
	author       = {Christoph Reichenbach and Neil Immerman and Yannis Smaragdakis and Edward Aftandilian and Samuel Z. Guyer},
	year         = 2010,
	booktitle    = {Proceedings of the 25th Annual {ACM} {SIGPLAN} Conference on Object-Oriented Programming, Systems, Languages, and Applications, {OOPSLA} 2010, October 17-21, 2010, Reno/Tahoe, Nevada, {USA}},
	publisher    = {{ACM}},
	pages        = {256--269}
}
@inproceedings{dura2021javadl,
	title        = {{JavaDL: Automatically Incrementalizing Java Bug Pattern Detection}},
	author       = {Alexandru Dura and Christoph Reichenbach and Emma S{\"o}derberg},
	year         = 2021,
	month        = {Sep},
	booktitle    = {Proceedings of the ACM on Programming Languages},
	location     = {Virtual},
	publisher    = {ACM},
	doi          = {10.1145/3485542},
	issue        = {OOPSLA 2021}
}
@inproceedings{jCT,
	title        = {{jCT: A Java Code Tomograph}},
	author       = {Lumpe, Markus and Mahmud, Samiran and Goloshchapova, Olga},
	year         = 2011,
	booktitle    = {2011 26th IEEE/ACM International Conference on Automated Software Engineering (ASE 2011)},
	volume       = {},
	number       = {},
	pages        = {616--619},
	doi          = {10.1109/ASE.2011.6100139}
}
@inproceedings{merino2015explora,
	title        = {{Explora: A visualisation tool for metric analysis of software corpora}},
	author       = {Merino, Leonel and Lungu, Mircea and Nierstrasz, Oscar},
	year         = 2015,
	booktitle    = {2015 IEEE 3rd Working Conference on Software Visualization (VISSOFT)},
	pages        = {195--199},
	organization = {IEEE}
}
@manual{aniche-ck,
	title        = {Java code metrics calculator (CK)},
	author       = {Maurício Aniche},
	year         = 2015,
	note         = {Available in https://github.com/mauricioaniche/ck/}
}
@inproceedings{luo_et_al:LIPIcs:2019:10813,
	title        = {{MagpieBridge: A General Approach to Integrating Static Analyses into IDEs and Editors (Tool Insights Paper)}},
	author       = {Linghui Luo and Julian Dolby and Eric Bodden},
	year         = 2019,
	booktitle    = {33rd European Conference on Object-Oriented Programming (ECOOP 2019)},
	publisher    = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
	address      = {Dagstuhl, Germany},
	series       = {Leibniz International Proceedings in Informatics (LIPIcs)},
	volume       = 134,
	pages        = {21:1--21:25},
	doi          = {10.4230/LIPIcs.ECOOP.2019.21},
	isbn         = {978-3-95977-111-5},
	issn         = {1868-8969},
	url          = {http://drops.dagstuhl.de/opus/volltexte/2019/10813},
	editor       = {Alastair F. Donaldson},
	urn          = {urn:nbn:de:0030-drops-108139},
	annote       = {Keywords: IDE, Tool Support, Static Analysis, Language Server Protocol}
}
@phdthesis{boyland1996descriptional,
	title        = {Descriptional Composition of Compiler Components},
	author       = {Boyland, John Tang},
	year         = 1996,
	school       = {University of California, Berkeley}
}
@article{chidamber1994metrics,
	title        = {A metrics suite for object oriented design},
	author       = {Chidamber, Shyam R and Kemerer, Chris F},
	year         = 1994,
	journal      = {IEEE Transactions on software engineering},
	publisher    = {IEEE},
	volume       = 20,
	number       = 6,
	pages        = {476--493}
}

@misc{Riouak2024Artifact,
  title  = {Efficient Demand Evaluation of Fixed-Point Attributes Using Static Analysis (Artifact)},
  author = {Riouak, I. and Fors, N. and Öqvist, J. and Hedin, G. and Reichenbach, C.},
  doi    = {10.5281/zenodo.13365896},
  year   = {2024}
}
@inproceedings{githubCorpus2013,
	title        = {{Mining Source Code Repositories at Massive Scale using Language Modeling}},
	author       = {Allamanis, Miltiadis and Sutton, Charles},
	year         = 2013,
	booktitle    = {The 10th Working Conference on Mining Software Repositories},
	pages        = {207--216},
	organization = {IEEE}
}
@inproceedings{bodden2011tamiflex,
	title        = {Taming reflection: Aiding static analysis in the presence of reflection and custom class loaders},
	author       = {E. {Bodden} and A. {Sewe} and J. {Sinschek} and H. {Oueslati} and M. {Mezini}},
	year         = 2011,
	month        = {may},
	booktitle    = {2011 33rd International Conference on Software Engineering (ICSE)},
	pages        = {241--250},
	doi          = {10.1145/1985793.1985827},
	issn         = {1558-1225}
}
@inproceedings{cok2018reasoning,
	title        = {Reasoning about functional programming in Java and C++},
	author       = {Cok, David R},
	year         = 2018,
	booktitle    = {Companion Proceedings for the ISSTA/ECOOP 2018 Workshops},
	pages        = {37--39}
}
@article{li2014rfbi,
	title        = {Residual Investigation: Predictive and Precise Bug Detection},
	author       = {Li, Kaituo and Reichenbach, Christoph and Csallner, Christoph and Smaragdakis, Yannis},
	year         = 2014,
	month        = {Dec},
	journal      = {ACM Trans. Softw. Eng. Methodol.},
	publisher    = {ACM},
	address      = {New York, NY, USA},
	volume       = 24,
	number       = 2,
	pages        = {7:1--7:32},
	doi          = {10.1145/2656201},
	issn         = {1049-331X},
	url          = {http://doi.acm.org/10.1145/2656201},
	acmid        = 2656201,
	articleno    = 7,
	issue_date   = {December 2014},
	keywords     = {False warnings, RFBI, existing test cases},
	numpages     = 32
}
@article{smaragdakis2012sound,
	title        = {Sound predictive race detection in polynomial time},
	author       = {Smaragdakis, Yannis and Evans, Jacob and Sadowski, Caitlin and Yi, Jaeheon and Flanagan, Cormac},
	year         = 2012,
	journal      = {ACM Sigplan Notices},
	publisher    = {ACM New York, NY, USA},
	volume       = 47,
	number       = 1,
	pages        = {387--400}
}
@misc{java1,
	title        = {{JDK 1.1 New Feature Summary}},
	publisher    = {Oracle},
	note         = {{Note:} Available as file jdk1.1.8/docs/relnotes/features.html in zip file for Java Development Kit (JDK) Documentation 1.1 (jdk118-doc.zip) at \url{https://www.oracle.com/java/technologies/java-archive-downloads-javase11-downloads.html} (login needed), {Last accessed: 2023-02-17}},
	key          = {java1}
}
@misc{java2,
	title        = {{Java 2 SDK, Standard Edition, version 1.2. Summary of New Features and Enhancements}},
	publisher    = {Oracle},
	note         = {{Note:} Available as file jdk1.2.2.202/docs/relnotes/features.html in zip file for Java 2 SDK, Standard Edition Documentation 1.2.2\_006 (jdk-1\_2\_2\_006-doc.zip) at \url{https://www.oracle.com/java/technologies/java-archive-javase-v12-downloads.html} (login needed), {Last accessed: 2023-02-17}},
	key          = {java2}
}
@misc{java3,
	title        = {{Java 2 SDK, Standard Edition, version 1.3. Summary of New Features and Enhancements}},
	publisher    = {Oracle},
	note         = {{Note:} Available as file docs/relnotes/features.html in zip file for Java 2 SDK, Standard Edition Documentation 1.3.1 (java1.3.zip) at \url{https://www.oracle.com/java/technologies/java-archive-13docs-downloads.html} (login needed), {Last accessed: 2023-02-17}},
	key          = {java3}
}
@book{java4,
	title        = {{Java 2 Sdk for Solaris Developer's Guide}},
	year         = 2000,
	publisher    = {Sun Microsystems},
	note         = {{ISBN:} 978-14-005-2241-5, {Note: Includes description of New Features and Enhancements for Java 1.4.}},
	key          = {java4}
}
@misc{java5,
	title        = {{New Features and Enhancements. J2SE 5.0}},
	publisher    = {Oracle},
	note         = {{Accessed:} 2023-02-17},
	howpublished = {\url{https://docs.oracle.com/javase/1.5.0/docs/relnotes/features.html}},
	key          = {java5}
}
@misc{java6,
	title        = {{Java SE 6 Features and Enhancements}},
	publisher    = {Oracle},
	note         = {{Accessed:} 2023-02-17},
	howpublished = {\url{https://www.oracle.com/java/technologies/javase/features.html}},
	key          = {java6}
}
@misc{java7,
	title        = {{Java SE 7 Features and Enhancements}},
	publisher    = {Oracle},
	note         = {{Accessed:} 2023-02-17},
	howpublished = {\url{https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html}},
	key          = {java7}
}
@misc{java8,
	title        = {{What's New in JDK 8}},
	publisher    = {Oracle},
	note         = {{Accessed:} 2023-02-17},
	howpublished = {\url{https://www.oracle.com/java/technologies/javase/8-whats-new.html}},
	key          = {java8}
}
@misc{Rust_Query_Guide,
	title        = {Query Guide},
	author       = {Rust Programming Language},
	year         = 2021,
	url          = {\url{https://rustc-dev-guide.rust-lang.org/query.html}},
	note         = {Accessed: 2023-01-27},
	howpublished = {\url{https://rustc-dev-guide.rust-lang.org/query.html}}
}
@inproceedings{Kiczales1997Aspect,
	title        = {Aspect-oriented programming},
	author       = {Kiczales, Gregor and Lamping, John and Mendhekar, Anurag and Maeda, Chris and Lopes, Cristina and Loingtier, Jean-Marc and Irwin, John},
	year         = 1997,
	booktitle    = {ECOOP'97 --- Object-Oriented Programming},
	publisher    = {Springer Berlin Heidelberg},
	address      = {Berlin, Heidelberg},
	pages        = {220--242},
	isbn         = {978-3-540-69127-3},
	editor       = {Ak{\c{s}}it, Mehmet and Matsuoka, Satoshi},
	abstract     = {We have found many programming problems for which neither procedural nor object-oriented programming techniques are sufficient to clearly capture some of the important design decisions the program must implement. This forces the implementation of those design decisions to be scattered throughout the code, resulting in ``tangled'' code that is excessively difficult to develop and maintain. We present an analysis of why certain design decisions have been so difficult to clearly capture in actual code. We call the properties these decisions address aspects, and show that the reason they have been hard to capture is that they cross-cut the system's basic functionality. We present the basis for a new programming technique, called aspect-oriented programming, that makes it possible to clearly express programs involving such aspects, including appropriate isolation, composition and reuse of the aspect code. The discussion is rooted in systems we have built using aspect-oriented programming.}
}
@article{Shafer2010Oil,
	title        = {The BP Oil Spill: Could Software be a Culprit?},
	author       = {Shafer, Don and Laplante, Phillip A.},
	year         = 2010,
	journal      = {IT Professional},
	volume       = 12,
	number       = 5,
	pages        = {6--9},
	doi          = {10.1109/MITP.2010.136}
}
@article{Sawyer1999,
	title        = {Mystery of Orbiter Crash Solved},
	author       = {Sawyer, Kathy},
	year         = 1999,
	journal      = {Washington Post},
	pages        = {A1},
	url          = {https://www.washingtonpost.com/wp-srv/national/longterm/space/stories/orbiter100199.htm},
	note         = {Accessed: 2023-01-27},
	howpublished = {https://www.washingtonpost.com/wp-srv/national/longterm/space/stories/orbiter100199.htm},
	date         = {1999-10-01}
}
@article{leveson1993investigation,
	title        = {An investigation of the Therac-25 accidents},
	author       = {Leveson, Nancy G and Turner, Clark S},
	year         = 1993,
	journal      = {Computer},
	publisher    = {IEEE},
	volume       = 26,
	number       = 7,
	pages        = {18--41}
}
@article{kane2010update,
  title={Update Report: Toyota Sudden Unintended Acceleration},
  author={Kane, Sean and Liberman, Ellen and DiViesti, Tony and Click, Felix and MacDonald, Melanie},
  journal={Safety Research \& Strategies (SRS)},
  year={2010}
}
@book{reinders2005vtune,
	title        = {VTune performance analyzer essentials},
	author       = {Reinders, James},
	year         = 2005,
	publisher    = {Intel Press Santa Clara},
	volume       = 9
}
@article{li2018fuzzing,
	title        = {Fuzzing: a survey},
	author       = {Li, Jun and Zhao, Bodong and Zhang, Chao},
	year         = 2018,
	journal      = {Cybersecurity},
	publisher    = {SpringerOpen},
	volume       = 1,
	number       = 1,
	pages        = {1--13}
}
@article{Baldoni2018Survey,
	title        = {A Survey of Symbolic Execution Techniques},
	author       = {Baldoni, Roberto and Coppa, Emilio and D’elia, Daniele Cono and Demetrescu, Camil and Finocchi, Irene},
	year         = 2018,
	month        = {may},
	journal      = {ACM Comput. Surv.},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 51,
	number       = 3,
	doi          = {10.1145/3182657},
	issn         = {0360-0300},
	url          = {https://doi.org/10.1145/3182657},
	issue_date   = {May 2019},
	abstract     = {Many security and software testing applications require checking whether certain properties of a program hold for any possible usage scenario. For instance, a tool for identifying software vulnerabilities may need to rule out the existence of any backdoor to bypass a program’s authentication. One approach would be to test the program using different, possibly random inputs. As the backdoor may only be hit for very specific program workloads, automated exploration of the space of possible inputs is of the essence. Symbolic execution provides an elegant solution to the problem, by systematically exploring many possible execution paths at the same time without necessarily requiring concrete inputs. Rather than taking on fully specified input values, the technique abstractly represents them as symbols, resorting to constraint solvers to construct actual instances that would cause property violations. Symbolic execution has been incubated in dozens of tools developed over the past four decades, leading to major practical breakthroughs in a number of prominent software reliability applications. The goal of this survey is to provide an overview of the main ideas, challenges, and solutions developed in the area, distilling them for a broad audience.},
	articleno    = 50,
	numpages     = 39,
	keywords     = {concolic execution, static analysis, software testing, Symbolic execution}
}
@inproceedings{cadar2008klee,
	title        = {Klee: unassisted and automatic generation of high-coverage tests for complex systems programs.},
	author       = {Cadar, Cristian and Dunbar, Daniel and Engler, Dawson R and others},
	year         = 2008,
	booktitle    = {OSDI},
	volume       = 8,
	pages        = {209--224}
}
@article{Clarke1999BoundedMC,
	title        = {Bounded Model Checking},
	author       = {Clarke, Edmund M. and Grumberg, Orna and Peled, Doron A.},
	year         = 1999,
	journal      = {Formal Methods in System Design},
	publisher    = {Springer},
	volume       = 16,
	number       = 1,
	pages        = {7--34}
}
@inproceedings{bradley2012understanding,
	title        = {Understanding ic3},
	author       = {Bradley, Aaron R},
	year         = 2012,
	booktitle    = {Theory and Applications of Satisfiability Testing--SAT 2012: 15th International Conference, Trento, Italy, June 17-20, 2012. Proceedings 15},
	pages        = {1--14},
	organization = {Springer}
}
@inproceedings{cavada2014nuxmv,
	title        = {The nuXmv symbolic model checker},
	author       = {Cavada, Roberto and Cimatti, Alessandro and Dorigatti, Michele and Griggio, Alberto and Mariotti, Alessandro and Micheli, Andrea and Mover, Sergio and Roveri, Marco and Tonetta, Stefano},
	year         = 2014,
	booktitle    = {Computer Aided Verification: 26th International Conference, CAV 2014, Held as Part of the Vienna Summer of Logic, VSL 2014, Vienna, Austria, July 18-22, 2014. Proceedings 26},
	pages        = {334--342},
	organization = {Springer}
}
@book{bertot2013interactive,
	title        = {Interactive theorem proving and program development: Coq’Art: the calculus of inductive constructions},
	author       = {Bertot, Yves and Cast{\'e}ran, Pierre},
	year         = 2013,
	publisher    = {Springer Science \& Business Media}
}
@book{Nipkow2002Isabelle,
	title        = {Isabelle/HOL - A Proof Assistant for Higher-Order Logic},
	author       = {Nipkow, Tobias and Paulson, Lawrence C. and Wenzel, Markus},
	year         = 2002,
	publisher    = {Springer}
}
@article{livshits2015defense,
	title        = {In defense of soundiness: A manifesto},
	author       = {Livshits, Benjamin and Sridharan, Manu and Smaragdakis, Yannis and Lhot{\'a}k, Ond{\v{r}}ej and Amaral, J Nelson and Chang, Bor-Yuh Evan and Guyer, Samuel Z and Khedker, Uday P and M{\o}ller, Anders and Vardoulakis, Dimitrios},
	year         = 2015,
	journal      = {Communications of the ACM},
	publisher    = {ACM New York, NY, USA},
	volume       = 58,
	number       = 2,
	pages        = {44--46}
}
@inproceedings{reynolds2002separation,
	title        = {Separation logic: A logic for shared mutable data structures},
	author       = {Reynolds, John C},
	year         = 2002,
	booktitle    = {Proceedings 17th Annual IEEE Symposium on Logic in Computer Science},
	pages        = {55--74},
	organization = {IEEE}
}
@book{hoare1969axiomatic,
	title        = {An axiomatic basis for computer programming},
	author       = {Hoare, C.A.R.},
	year         = 1969,
	publisher    = {Communications of the ACM}
}
@inproceedings{calcagno2011infer,
	title        = {Infer: An automatic program verifier for memory safety of C programs},
	author       = {Calcagno, Cristiano and Distefano, Dino},
	year         = 2011,
	booktitle    = {NASA Formal Methods: Third International Symposium, NFM 2011, Pasadena, CA, USA, April 18-20, 2011. Proceedings 3},
	pages        = {459--465},
	organization = {Springer}
}
@book{pierce2002types,
	title        = {Types and programming languages},
	author       = {Pierce, Benjamin C},
	year         = 2002,
	publisher    = {MIT press}
}
@book{nielsen1994usability,
	title        = {Usability engineering},
	author       = {Nielsen, Jakob},
	year         = 1994,
	publisher    = {Morgan Kaufmann}
}
@article{Nadeem2022HumanCenteredAT,
	title        = {Human-Centered Approach to Static-Analysis-Driven Developer Tools},
	author       = {Nadeem, Ayman},
	year         = 2022,
	month        = {feb},
	journal      = {Commun. ACM},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 65,
	number       = 3,
	pages        = {38–45},
	doi          = {10.1145/3486597},
	issn         = {0001-0782},
	url          = {https://doi.org/10.1145/3486597},
	issue_date   = {March 2022},
	abstract     = {The future depends on good HCI.},
	numpages     = 8
}
@inproceedings{Luo2019MagpieBridge,
	title        = {{MagpieBridge: A General Approach to Integrating Static Analyses into IDEs and Editors (Tool Insights Paper)}},
	author       = {Linghui Luo and Julian Dolby and Eric Bodden},
	year         = 2019,
	booktitle    = {33rd European Conference on Object-Oriented Programming (ECOOP 2019)},
	publisher    = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
	address      = {Dagstuhl, Germany},
	series       = {Leibniz International Proceedings in Informatics (LIPIcs)},
	volume       = 134,
	pages        = {21:1--21:25},
	doi          = {10.4230/LIPIcs.ECOOP.2019.21},
	isbn         = {978-3-95977-111-5},
	issn         = {1868-8969},
	url          = {http://drops.dagstuhl.de/opus/volltexte/2019/10813},
	editor       = {Alastair F. Donaldson},
	urn          = {urn:nbn:de:0030-drops-108139},
	annote       = {Keywords: IDE, Tool Support, Static Analysis, Language Server Protocol}
}
@inproceedings{sadowski2015tricorder,
	title        = {Tricorder: Building a Program Analysis Ecosystem},
	author       = {Caitlin Sadowski and Jeffrey van Gogh and Ciera Jaspan and Emma S{\"{o}}derberg and Collin Winter},
	year         = 2015,
	booktitle    = {37th {IEEE/ACM} International Conference on Software Engineering, {ICSE} 2015, Florence, Italy, May 16-24, 2015, Volume 1},
	publisher    = {{IEEE} Computer Society},
	pages        = {598--608},
	doi          = {10.1109/ICSE.2015.76},
	url          = {https://doi.org/10.1109/ICSE.2015.76},
	editor       = {Antonia Bertolino and Gerardo Canfora and Sebastian G. Elbaum},
	biburl       = {https://dblp.org/rec/conf/icse/SadowskiGJSW15.bib}
}
@inproceedings{Sridharan2005Demand,
	title        = {Demand-Driven Points-to Analysis for Java},
	author       = {Sridharan, Manu and Gopan, Denis and Shan, Lexin and Bod\'{\i}k, Rastislav},
	year         = 2005,
	booktitle    = {Proceedings of the 20th Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications},
	location     = {San Diego, CA, USA},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {OOPSLA '05},
	pages        = {59–76},
	doi          = {10.1145/1094811.1094817},
	isbn         = 1595930310,
	url          = {https://doi.org/10.1145/1094811.1094817},
	abstract     = {We present a points-to analysis technique suitable for environments with small time and memory budgets, such as just-in-time (JIT) compilers and interactive development environments (IDEs). Our technique is demand-driven, performing only the work necessary to answer each query (a request for a variable's points-to information) issued by a client. In cases where even the demand-driven approach exceeds the time budget for a query, we employ early termination, i.e., stopping the analysis prematurely and returning an over-approximated result to the client. Our technique improves on previous demand-driven points-to analysis algorithms [17, 33] by achieving much higher precision under small time budgets and early termination.We formulate Andersen's analysis [5] for Java as a CFL-reachability problem [33]. This formulation shows that Andersen's analysis for Java is a balanced-parentheses problem, an insight that enables our new techniques. We exploit the balanced parentheses structure to approximate Andersen's analysis by regularizing the CFL-reachability problem, yielding an asymptotically cheaper algorithm. We also show how to regain most of the precision lost in the regular approximation as needed through refinement. Our evaluation shows that our regularization and refinement approach achieves nearly the precision of field-sensitive Andersen's analysis in time budgets as small as 2ms per query. Our technique can yield speedups of up to 16x over computing an exhaustive Andersen's analysis for some clients, with little to no precision loss.},
	numpages     = 18,
	keywords     = {demand-driven analysis, points-to analysis, context-free language reachability, refinement}
}


@article{arrhen2024pointer,
  title={Pointer Analysis for Interactive Programming Environments},
  author={Arrh{\'e}n, Johan and Wiklund, Ruben},
  year={2024},
  publisher={Lund University},
  note={Master's Thesis}
}
@inproceedings{spath2016boomerang,
	title        = {Boomerang: Demand-driven flow-and context-sensitive pointer analysis for java},
	author       = {Sp{\"a}th, Johannes and Nguyen Quang Do, Lisa and Ali, Karim and Bodden, Eric},
	year         = 2016,
	booktitle    = {30th European Conference on Object-Oriented Programming (ECOOP 2016)},
	organization = {Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik}
}
@article{lisa1995tool,
	title        = {LISA: A Tool for Automatic Language Implementation},
	author       = {Mernik, Marjan and Korbar, Nikolaj and \v{Z}umer, Viljem},
	year         = 1995,
	month        = {apr},
	journal      = {SIGPLAN Not.},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 30,
	number       = 4,
	pages        = {71–79},
	doi          = {10.1145/202176.202185},
	issn         = {0362-1340},
	url          = {https://doi.org/10.1145/202176.202185},
	issue_date   = {April 1995},
	abstract     = {In the paper a tool for automatic language implementation is described. From formal language definition LISA1 produces efficient interpreters or compilers in C++. For lexical and syntax analysis well known formal methods: regular expressions and BNF are used. Semantics of the defined language is described with attribute grammars. LISA is a part of the ongoing effort to build an environment that supports experimentation in automatic language implementation for educational and industrial purposes.},
	numpages     = 9
}
@techreport{cocor1990johannes,
	title        = {Coco/R - A Generator for Fast Compiler Front Ends},
	author       = {Mossenbock, H.},
	year         = 1990,
	publisher    = {Johannes Kepler Universitat Linz},
	abstract     = {Formal compiler descriptions serve two purposes: (1) they can be used as a reference document which specifies the syntax and the semantics of a language, and (2) they provide a convenient notation from which efficient compilers can be generated. Compiler generating systems put emphasis on either the one or the other of these aspects. The system described in this report mainly concentrates on the second goal. We show that it is possible to generate compilers that are as efficient as hand-coded and carefully optimized production-quality compilers. Our system generates recursive descent parsers with a simple error-handling mechanism and scanners with a special buffering scheme. Almost as important as efficiency is the simplicity and adequacy of the system. Programmers are not willing to use a tool if it does not come in handy in their work, if it uses a cryptic notation or a multitude of options and special cases. The tool should make their work easier without limiting their flexibility. We used our system to generate an Oberon compiler that is even faster than the standard Oberon compiler used at ETH.}
}

@article{FORS201574,
  title    = {A JastAdd implementation of Oberon-0},
  journal  = {Science of Computer Programming},
  volume   = {114},
  pages    = {74-84},
  year     = {2015},
  note     = {LDTA (Language Descriptions, Tools, and Applications) Tool Challenge},
  issn     = {0167-6423},
  doi      = {https://doi.org/10.1016/j.scico.2015.02.002},
  url      = {https://www.sciencedirect.com/science/article/pii/S016764231500026X},
  author   = {Niklas Fors and Görel Hedin},
  keywords = {JastAdd, Reference attribute grammars},
  abstract = {As a part of the LDTA 2011 Tool Challenge, we implemented a compiler for the language Oberon-0 using the metacompilation tool JastAdd. In this paper, we report on this implementation, and reflect on aspects of it such as ease of use, modularity, and safety.}
}
@book{optmising2001compilers,
	title        = {Optimizing Compilers for Modern Architectures: A Dependence-Based Approach},
	author       = {Kennedy, Ken and Allen, John R.},
	year         = 2001,
	publisher    = {Morgan Kaufmann Publishers Inc.},
	address      = {San Francisco, CA, USA},
	isbn         = 1558602860,
	abstract     = {Modern computer architectures designed with high-performance microprocessors offer tremendous potential gains in performance over previous designs. Yet their very complexity makes it increasingly difficult to produce efficient code and to realize their full potential. This landmark text from two leaders in the field focuses on the pivotal role that compilers can play in addressing this critical issue. The basis for all the methods presented in this book is data dependence, a fundamental compiler analysis tool for optimizing programs on high-performance microprocessors and parallel architectures. It enables compiler designers to write compilers that automatically transform simple, sequential programs into forms that can exploit special features of these modern architectures. The text provides a broad introduction to data dependence, to the many transformation strategies it supports, and to its applications to important optimization problems such as parallelization, compiler memory hierarchy management, and instruction scheduling. The authors demonstrate the importance and wide applicability of dependence-based compiler optimizations and give the compiler writer the basics needed to understand and implement them. They also offer cookbook explanations for transforming applications by hand to computational scientists and engineers who are driven to obtain the best possible performance of their complex applications.}
}
@inproceedings{mosaner2022machine,
	title        = {Machine-Learning-Based Self-Optimizing Compiler Heuristics},
	author       = {Mosaner, Raphael and Leopoldseder, David and Kisling, Wolfgang and Stadler, Lukas and M\"{o}ssenb\"{o}ck, Hanspeter},
	year         = 2022,
	booktitle    = {Proceedings of the 19th International Conference on Managed Programming Languages and Runtimes},
	location     = {Brussels, Belgium},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {MPLR '22},
	pages        = {98–111},
	doi          = {10.1145/3546918.3546921},
	isbn         = 9781450396967,
	url          = {https://doi.org/10.1145/3546918.3546921},
	abstract     = {Compiler optimizations are often based on hand-crafted heuristics to guide the optimization process. These heuristics are designed to benefit the average program and are otherwise static or only customized by profiling information. We propose machine-learning-based self-optimizing compiler heuristics, a novel approach for fitting optimization decisions in a dynamic compiler to specific environments. This is done by updating a machine learning model with extracted performance data at run time. Related work—which primarily targets static compilers—has already shown that machine learning can outperform hand-crafted heuristics. Our approach is specifically designed for dynamic compilation and uses concepts such as deoptimization for transparently switching between generating data and performing machine learning decisions in single program runs. We implemented our approach in the GraalVM, a high-performance production VM for dynamic compilation. When evaluating our approach by replacing loop peeling heuristics with learned models we encountered speedups larger than 30\% for several benchmarks and only few slowdowns of up to 7\%.},
	numpages     = 14,
	keywords     = {Machine Learning, Loop Peeling, Optimization, Performance, Neural Networks, Dynamic Compilation, Heuristics}
}
@techreport{jesper2017reference,
	title        = {{Concurrent Circular Reference Attribute Grammars (Extended Version)}},
	author       = {{Öqvist, Jesper and Hedin, Görel}},
	year         = {{2017}},
	month        = {{10}},
	series       = {{Technical report, LU-CS-TR}},
	number       = {{2017-254}},
	issn         = {{1404-1200}},
	url          = {https://lup.lub.lu.se/search/files/33513876/report.pdf},
	abstract     = {{Reference Attribute Grammars (RAGs) is a declarative executable formalism used for constructing compilers and related tools.  Existing implementations support concurrent evaluation only with global evaluation locks. This may lead to long latencies in interactive tools, where interactive and background threads query attributes concurrently.<br/><br/>We present lock-free algorithms for concurrent attribute evaluation, enabling low latency in interactive tools.  Our algorithms support important extensions to RAGs like circular (fixed-point) attributes and higher-order attributes.<br/><br/>We have implemented our algorithms in Java, for the JastAdd metacompiler.  We evaluate the implementation on a JastAdd-specified compiler for the Java language, demonstrating very low latencies for interactive attribute queries, on the order of milliseconds. Furthermore, initial experiments show a speedup of about a factor 2 when using four parallel compilation threads.}},
	institution  = {{Department of Computer Science, Lund University}},
	keywords     = {{Reference Attribute Grammar; Concurrency; Parallelization; Memoization; Circular Attributes}},
	language     = {{eng}}
}
@phdthesis{bacon1997fast,
	title        = {Fast and Effective Optimization of Statically Typed Object-Oriented Languages},
	author       = {Bacon, David Francis and Graham, Susan L.},
	year         = 1997,
	publisher    = {University of California, Berkeley},
	isbn         = {059181143X},
	note         = {AAI9828589},
	abstract     = {In this dissertation, we show how a relatively simple and extremely fast interprocedural optimization algorithm can be used to optimize many of the expensive features of statically typed, object-oriented languages--in particular, C++ and Java. We present a new program analysis algorithm, Rapid Type Analysis, and show that it is fast both in theory and in practice, and significantly out-performs other "fast" algorithms for virtual function call resolution.We present optimization algorithms for the resolution of virtual function calls, conversion of virtual inheritance to direct inheritance, elimination of dynamic casts and dynamic type checks, and removal of object synchronization. These algorithms are all presented within a common framework that allows them to be driven by the information collected by Rapid Type Analysis, or by some other type analysis algorithm.Collectively, the optimizations in this dissertation free the programmer from having to sacrifice modularity and extensibility for performance. Instead, the programmer can freely make use of the most powerful features of object-oriented programming, since the optimizer will remove unnecessary extensibility from the program.}
}
@inproceedings{dean1995optimization,
	title        = {Optimization of Object-Oriented Programs Using Static Class Hierarchy Analysis},
	author       = {Dean, Jeffrey and Grove, David and Chambers, Craig},
	year         = 1995,
	booktitle    = {Proceedings of the 9th European Conference on Object-Oriented Programming},
	publisher    = {Springer-Verlag},
	address      = {Berlin, Heidelberg},
	series       = {ECOOP '95},
	pages        = {77–101},
	isbn         = 3540601600,
	abstract     = {Optimizing compilers for object-oriented languages apply static class analysis and other techniques to try to deduce precise information about the possible classes of the receivers of messages; if successful, dynamically-dispatched messages can be replaced with direct procedure calls and potentially further optimized through inline-expansion. By examining the complete inheritance graph of a program, which we call class hierarchy analysis, the compiler can improve the quality of static class information and thereby improve run-time performance. In this paper we present class hierarchy analysis and describe techniques for implementing this analysis effectively in both statically- and dynamically-typed languages and also in the presence of multi-methods. We also discuss how class hierarchy analysis can be supported in an interactive programming environment and, to some extent, in the presence of separate compilation. Finally, we assess the bottom-line performance improvement due to class hierarchy analysis alone and in combination with two other "competing" optimizations, profile-guided receiver class prediction and method specialization.},
	numpages     = 25
}
@article{tarjan1972depthfirst,
	title        = {Depth-First Search and Linear Graph Algorithms},
	author       = {Tarjan, Robert},
	year         = 1972,
	month        = jun,
	journal      = {{SIAM} Journal on Computing},
	publisher    = {Society for Industrial {\&} Applied Mathematics ({SIAM})},
	volume       = 1,
	number       = 2,
	pages        = {146--160},
	doi          = {10.1137/0201010},
	url          = {https://doi.org/10.1137%2F0201010},
	added-at     = {2018-03-22T16:04:01.000+0100},
	biburl       = {https://www.bibsonomy.org/bibtex/2c5111f5c12f712ebfa496cb4be0e536a/achakraborty},
	description  = {Depth-First Search and Linear Graph Algorithms | SIAM Journal on Computing | Vol. 1, No. 2 | Society for Industrial and Applied Mathematics},
	interhash    = {84fa643834b66d69d6440e9a3103f24f},
	intrahash    = {c5111f5c12f712ebfa496cb4be0e536a},
	keywords     = {algorithms graph-theory linear-algebra paper search},
	timestamp    = {2018-03-22T16:04:01.000+0100}
}
@inproceedings{CousotCousot1977,
	title        = {Abstract Interpretation: {A} Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints},
	author       = {Patrick Cousot and Radhia Cousot},
	year         = 1977,
	booktitle    = {Conference Record of the Fourth {ACM} Symposium on Principles of Programming Languages, Los Angeles, California, USA, January 1977},
	publisher    = {{ACM}},
	pages        = {238--252},
	doi          = {10.1145/512950.512973},
	url          = {https://doi.org/10.1145/512950.512973},
	editor       = {Robert M. Graham and Michael A. Harrison and Ravi Sethi},
	timestamp    = {Tue, 06 Nov 2018 11:07:42 +0100},
	biburl       = {https://dblp.org/rec/conf/popl/CousotC77.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}
@article{Horwitz1987,
	title        = {An Efficient General Iterative Algorithm for Dataflow Analysis},
	author       = {Susan Horwitz and Alan J. Demers and Tim Teitelbaum},
	year         = 1987,
	journal      = {Acta Informatica},
	volume       = 24,
	number       = 6,
	pages        = {679--694},
	doi          = {10.1007/BF00282621},
	url          = {https://doi.org/10.1007/BF00282621},
	timestamp    = {Sun, 21 Jun 2020 17:37:56 +0200},
	biburl       = {https://dblp.org/rec/journals/acta/HorwitzDT87.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}
@article{Soderberg2013,
	title        = {Extensible intraprocedural flow analysis at the abstract syntax tree level},
	author       = {Emma S{\"{o}}derberg and Torbj{\"{o}}rn Ekman and G{\"{o}}rel Hedin and Eva Magnusson},
	year         = 2013,
	journal      = {Sci. Comput. Program.},
	volume       = 78,
	number       = 10,
	pages        = {1809--1827},
	doi          = {10.1016/J.SCICO.2012.02.002},
	url          = {https://doi.org/10.1016/j.scico.2012.02.002},
	timestamp    = {Wed, 17 Feb 2021 21:55:46 +0100},
	biburl       = {https://dblp.org/rec/journals/scp/SoderbergEHM13.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{Oqvist2017SLE,
	title        = {Concurrent circular reference attribute grammars},
	author       = {Jesper {\"{O}}qvist and G{\"{o}}rel Hedin},
	year         = 2017,
	booktitle    = {Proceedings of the 10th {ACM} {SIGPLAN} International Conference on Software Language Engineering, {SLE} 2017, Vancouver, BC, Canada, October 23-24, 2017},
	publisher    = {{ACM}},
	pages        = {151--162},
	doi          = {10.1145/3136014.3136032},
	url          = {https://doi.org/10.1145/3136014.3136032},
	editor       = {Beno{\^{\i}}t Combemale and Marjan Mernik and Bernhard Rumpe},
	timestamp    = {Thu, 21 Apr 2022 11:12:19 +0200},
	biburl       = {https://dblp.org/rec/conf/sle/OqvistH17.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}
@phdthesis{Oqvist18PhD,
	title        = {Contributions to Declarative Implementation of Static Program Analysis},
	author       = {Jesper {\"{O}}qvist},
	year         = 2018,
	url          = {http://lup.lub.lu.se/record/82b210fc-6d15-4f0a-82ff-24b024925d23},
	school       = {Lund University, Sweden},
	timestamp    = {Thu, 12 Mar 2020 11:24:01 +0100},
	biburl       = {https://dblp.org/rec/phd/basesearch/Oqvist18.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}
@article{Sassa03,
	title        = {Circular Attribute Grammars with Remote Attribute References and their Evaluators},
	author       = {Akira Sasaki and Masataka Sassa},
	year         = 2003,
	journal      = {New Generation Computing},
	publisher    = {Springer},
	volume       = 22,
	number       = 1,
	pages        = {37--60},
	doi          = {10.1007/BF03037280},
	url          = {https://doi.org/10.1007/BF03037280}
}
@article{SoderbergCNTA2015,
	title        = {Declarative rewriting through circular nonterminal attributes},
	author       = {Emma S{\"{o}}derberg and G{\"{o}}rel Hedin},
	year         = 2015,
	journal      = {Computer Languages, Systems \& Structures},
	publisher    = {Elsevier},
	volume       = 44,
	pages        = {3--23},
	doi          = {10.1016/J.CL.2015.08.008},
	url          = {https://doi.org/10.1016/j.cl.2015.08.008},
	timestamp    = {Tue, 11 Feb 2020 17:00:46 +0100},
	biburl       = {https://dblp.org/rec/journals/cl/SoderbergH15.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{SteinPLDI2021,
	title        = {Demanded abstract interpretation},
	author       = {Benno Stein and Bor{-}Yuh Evan Chang and Manu Sridharan},
	year         = 2021,
	booktitle    = {{PLDI} '21: 42nd {ACM} {SIGPLAN} International Conference on Programming Language Design and Implementation, Virtual Event, Canada, June 20-25, 2021},
	publisher    = {{ACM}},
	pages        = {282--295},
	doi          = {10.1145/3453483.3454044},
	url          = {https://doi.org/10.1145/3453483.3454044},
	editor       = {Stephen N. Freund and Eran Yahav}
}
@inproceedings{DuesterwaldPOPL1995,
	title        = {Demand-driven Computation of Interprocedural Data Flow},
	author       = {Evelyn Duesterwald and Rajiv Gupta and Mary Lou Soffa},
	year         = 1995,
	booktitle    = {Conference Record of POPL'95: 22nd {ACM} {SIGPLAN-SIGACT} Symposium on Principles of Programming Languages, San Francisco, California, USA, January 23-25, 1995},
	publisher    = {{ACM} Press},
	pages        = {37--48},
	doi          = {10.1145/199448.199461},
	url          = {https://doi.org/10.1145/199448.199461},
	editor       = {Ron K. Cytron and Peter Lee}
}
@inproceedings{HorwitzFSE1995,
	title        = {Demand Interprocedural Dataflow Analysis},
	author       = {Susan Horwitz and Thomas W. Reps and Shmuel Sagiv},
	year         = 1995,
	booktitle    = {Proceedings of the Third {ACM} {SIGSOFT} Symposium on Foundations of Software Engineering, {SIGSOFT} 1995, Washington, DC, USA, October 10-13, 1995},
	publisher    = {{ACM}},
	pages        = {104--115},
	doi          = {10.1145/222124.222146},
	url          = {https://doi.org/10.1145/222124.222146},
	editor       = {Gail E. Kaiser}
}
@inproceedings{BodikOOPSLA2005,
	title        = {Demand-driven points-to analysis for Java},
	author       = {Manu Sridharan and Denis Gopan and Lexin Shan and Rastislav Bod{\'{\i}}k},
	year         = 2005,
	booktitle    = {Proceedings of the 20th Annual {ACM} {SIGPLAN} Conference on Object-Oriented Programming, Systems, Languages, and Applications, {OOPSLA} 2005, October 16-20, 2005, San Diego, CA, {USA}},
	publisher    = {{ACM}},
	pages        = {59--76},
	doi          = {10.1145/1094811.1094817},
	url          = {https://doi.org/10.1145/1094811.1094817},
	editor       = {Ralph E. Johnson and Richard P. Gabriel}
}
@inproceedings{BoddenECOOP2016,
	title        = {Boomerang: Demand-Driven Flow- and Context-Sensitive Pointer Analysis for Java},
	author       = {Johannes Sp{\"{a}}th and Lisa Nguyen Quang Do and Karim Ali and Eric Bodden},
	year         = 2016,
	booktitle    = {30th European Conference on Object-Oriented Programming, {ECOOP} 2016, July 18-22, 2016, Rome, Italy},
	publisher    = {Schloss Dagstuhl - Leibniz-Zentrum f{\"{u}}r Informatik},
	series       = {LIPIcs},
	volume       = 56,
	pages        = {22:1--22:26},
	doi          = {10.4230/LIPICS.ECOOP.2016.22},
	url          = {https://doi.org/10.4230/LIPIcs.ECOOP.2016.22},
	editor       = {Shriram Krishnamurthi and Benjamin S. Lerner}
}
@article{bacon1996fast,
	title        = {Fast Static Analysis of C++ Virtual Function Calls},
	author       = {Bacon, David F. and Sweeney, Peter F.},
	year         = 1996,
	month        = {oct},
	journal      = {SIGPLAN Not.},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 31,
	number       = 10,
	pages        = {324–341},
	doi          = {10.1145/236338.236371},
	issn         = {0362-1340},
	url          = {https://doi.org/10.1145/236338.236371},
	issue_date   = {Oct. 1996},
	abstract     = {Virtual functions make code easier for programmers to reuse but also make it harder for compilers to analyze. We investigate the ability of three static analysis algorithms to improve C++ programs by resolving virtual function calls, thereby reducing compiled code size and reducing program complexity so as to improve both human and automated program understanding and analysis. In measurements of seven programs of significant size (5000 to 20000 lines of code each) we found that on average the most precise of the three algorithms resolved 71\% of the virtual function calls and reduced compiled code size by 25\%. This algorithm is very fast: it analyzes 3300 source lines per second on an 80 MHz PowerPC 601. Because of its accuracy and speed, this algorithm is an excellent candidate for inclusion in production C++ compilers.},
	numpages     = 18
}
@inproceedings{soderberg2011automated,
	title        = {Automated Selective Caching for Reference Attribute Grammars},
	author       = {S{\"o}derberg, Emma and Hedin, G{\"o}rel},
	year         = 2011,
	booktitle    = {Software Language Engineering},
	publisher    = {Springer Berlin Heidelberg},
	address      = {Berlin, Heidelberg},
	pages        = {2--21},
	isbn         = {978-3-642-19440-5},
	editor       = {Malloy, Brian and Staab, Steffen and van den Brand, Mark},
	abstract     = {Reference attribute grammars (RAGs) can be used to express semantics as super-imposed graphs on top of abstract syntax trees (ASTs). A RAG-based AST can be used as the in-memory model providing semantic information for software language tools such as compilers, refactoring tools, and meta-modeling tools. RAG performance is based on dynamic attribute evaluation with caching. Caching all attributes gives optimal performance in the sense that each attribute is evaluated at most once. However, performance can be further improved by a selective caching strategy, avoiding caching overhead where it does not pay off. In this paper we present a profiling-based technique for automatically finding a good cache configuration. The technique has been evaluated on a generated Java compiler, compiling programs from the Jacks test suite and the DaCapo benchmark suite.}
}
@article{abadi1996analysis,
	title        = {Analysis and caching of dependencies},
	author       = {Abadi, Mart\'{\i}n and Lampson, Butler and L\'{e}vy, Jean-Jacques},
	year         = 1996,
	month        = {jun},
	journal      = {SIGPLAN Not.},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 31,
	number       = 6,
	pages        = {83–91},
	doi          = {10.1145/232629.232638},
	issn         = {0362-1340},
	url          = {https://doi.org/10.1145/232629.232638},
	issue_date   = {June 15, 1996},
	abstract     = {We address the problem of dependency analysis and caching in the context of the λ-calculus. The dependencies of a λ-term are (roughly) the parts of the λ-term that contribute to the result of evaluating it. We introduce a mechanism for keeping track of dependencies, and discuss how to use these dependencies in caching.},
	numpages     = 9
}
@phdthesis{hesamian2023circularremote,
	title        = {Statically Scheduling Circular Remote Attribute Grammars},
	author       = {Seyedamirhossein Hesamian},
	year         = 2023,
	note         = {Theses and Dissertations. 3383},
	school       = {University of Wisconsin-Milwaukee}
}
@misc{Magnusson2007artifact,
	title        = {{CRAG artifact}},
	author       = {Eva Magnusson and G{\"o}rel Hedin},
	year         = 2007,
	note         = {Accessed: 2024-04-01},
	howpublished = {\url{https://bitbucket.org/jastadd/crag-artifact}}
}
@inproceedings{demoor2007ql,
	title        = {{.QL: Object-oriented queries made easy}},
	author       = {De Moor, Oege and Sereni, Damien and Verbaere, Mathieu and Hajiyev, Elnar and Avgustinov, Pavel and Ekman, Torbj{\"o}rn and Ongkingco, Neil and Tibble, Julian},
	year         = 2007,
	booktitle    = {International Summer School on Generative and Transformational Techniques in Software Engineering},
	pages        = {78--133},
	organization = {Springer}
}

@inproceedings{dura2024clog,
	title        = {Clog: A Declarative Language for C Static Code Checkers},
	author       = {Dura, Alexandru and Reichenbach, Christoph},
	year         = 2024,
	booktitle    = {Proceedings of the 33rd ACM SIGPLAN International Conference on Compiler Construction},
	location     = {, Edinburgh, United Kingdom},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {CC 2024},
	pages        = {186–197},
	doi          = {10.1145/3640537.3641579},
	isbn         = 9798400705076,
	url          = {https://doi.org/10.1145/3640537.3641579},
	numpages     = 12,
	keywords     = {C, Datalog, Static Analysis Frameworks, Syntactic Patterns}
}
@inproceedings{bancilhon1985magic,
	title        = {Magic sets and other strange ways to implement logic programs},
	author       = {Bancilhon, Francois and Maier, David and Sagiv, Yehoshua and Ullman, Jeffrey D},
	year         = 1985,
	booktitle    = {Proceedings of the fifth ACM SIGACT-SIGMOD symposium on Principles of database systems},
	pages        = {1--15}
}
@inproceedings{WykKBS07,
	title        = {Attribute Grammar-Based Language Extensions for Java},
	author       = {Eric Van Wyk and Lijesh Krishnan and Derek Bodin and August Schwerdfeger},
	year         = 2007,
	booktitle    = {{ECOOP} 2007 - Object-Oriented Programming, 21st European Conference, Berlin, Germany, July 30 - August 3, 2007, Proceedings},
	publisher    = {Springer},
	series       = {Lecture Notes in Computer Science},
	volume       = 4609,
	pages        = {575--599},
	doi          = {10.1007/978-3-540-73589-2\_27},
	url          = {https://doi.org/10.1007/978-3-540-73589-2\_27},
	editor       = {Erik Ernst},
	timestamp    = {Tue, 14 May 2019 10:00:54 +0200},
	biburl       = {https://dblp.org/rec/conf/ecoop/WykKBS07.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}
@article{KaminskiKCW17,
	title        = {Reliable and automatic composition of language extensions to {C:} the ableC extensible language framework},
	author       = {Ted Kaminski and Lucas Kramer and Travis Carlson and Eric Van Wyk},
	year         = 2017,
	journal      = {Proc. {ACM} Program. Lang.},
	volume       = 1,
	number       = {{OOPSLA}},
	pages        = {98:1--98:29},
	doi          = {10.1145/3138224},
	url          = {https://doi.org/10.1145/3138224},
	timestamp    = {Wed, 17 Feb 2021 08:53:57 +0100},
	biburl       = {https://dblp.org/rec/journals/pacmpl/KaminskiKCW17.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}
@article{AkessonAGBT10,
	title        = {Modeling and optimization with Optimica and JModelica.org - Languages and tools for solving large-scale dynamic optimization problems},
	author       = {Johan {\AA}kesson and Karl{-}Erik {\AA}rz{\'{e}}n and Magnus G{\"{a}}fvert and Tove Bergdahl and Hubertus Tummescheit},
	year         = 2010,
	journal      = {Comput. Chem. Eng.},
	volume       = 34,
	number       = 11,
	pages        = {1737--1749},
	doi          = {10.1016/J.COMPCHEMENG.2009.11.011},
	url          = {https://doi.org/10.1016/j.compchemeng.2009.11.011},
	timestamp    = {Mon, 18 May 2020 12:45:35 +0200},
	biburl       = {https://dblp.org/rec/journals/cce/AkessonAGBT10.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{ForsH16,
	title        = {Bloqqi: modular feature-based block diagram programming},
	author       = {Niklas Fors and G{\"{o}}rel Hedin},
	year         = 2016,
	booktitle    = {2016 {ACM} International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software, Onward! 2016, Amsterdam, The Netherlands, November 2-4, 2016},
	publisher    = {{ACM}},
	pages        = {57--73},
	doi          = {10.1145/2986012.2986026},
	url          = {https://doi.org/10.1145/2986012.2986026},
	editor       = {Eelco Visser and Emerson R. Murphy{-}Hill and Cristina V. Lopes},
	timestamp    = {Tue, 27 Dec 2022 12:44:40 +0100},
	biburl       = {https://dblp.org/rec/conf/oopsla/ForsH16.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}
@article{wegman1991composition,
	title        = {{Constant Propagation with Conditional Branches}},
	author       = {Mark N. Wegman and F. Kennneth Zadeck},
	year         = 1991,
	month        = {April},
	journal      = {ACM Trans. Program. Lang. Syst.},
	volume       = 13,
	number       = 2,
	pages        = {181--210}
}
@inproceedings{buckley2017saiga,
	title        = {A formalisation of parameterised reference attribute grammars},
	author       = {Buckley, Scott JH and Sloane, Anthony M},
	year         = 2017,
	booktitle    = {Proceedings of the 10th ACM SIGPLAN International Conference on Software Language Engineering},
	pages        = {139--150}
}




@inproceedings{10.1145/73141.74830,
	title        = {Higher Order Attribute Grammars},
	author       = {Vogt, H. H. and Swierstra, S. D. and Kuiper, M. F.},
	year         = 1989,
	booktitle    = {Proceedings of the ACM SIGPLAN 1989 Conference on Programming Language Design and Implementation},
	location     = {Portland, Oregon, USA},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {PLDI '89},
	pages        = {131–145},
	doi          = {10.1145/73141.74830},
	isbn         = {089791306X},
	url          = {https://doi.org/10.1145/73141.74830},
	abstract     = {A new kind of attribute grammars, called higher order attribute grammars, is defined. In higher order attribute grammars the structure tree can be expanded as a result of attribute computation. A structure tree may be stored in an attribute. The term higher order is used because of the analogy with higher order functions, where a function can be the result or parameter of another function. A relatively simple method, using OAGs, is described to derive an evaluation order on the defining attribute occurrences which comprises all possible direct and indirect attribute dependencies. As in OAGs, visit-sequences are computed from which an efficient algorithm for attribute evaluation can be derived.},
	numpages     = 15
}


@inproceedings{sundaresan2000practical,
  author    = {Vivek Sundaresan and Laurie Hendren and Raja Vall{\'e}e-Rai and Patrick Lam and Etienne Gagnon and Charles L. McKenney},
  title     = {Practical Virtual Method Call Resolution for Java},
  booktitle = {Proceedings of the 15th ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA 2000)},
  year      = {2000},
  pages     = {264--280},
  publisher = {ACM}
}

@phdthesis{andersen1994program,
  author = {Lars Ole Andersen},
  title  = {Program Analysis and Specialization for the C Programming Language},
  year   = {1994},
  school = {DIKU, University of Copenhagen}
}












@inproceedings{ekman2007jastadd,
  title     = {The jastadd extensible Java compiler},
  author    = {Ekman, Torbj{\"o}rn and Hedin, G{\"o}rel},
  booktitle = {Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications},
  pages     = {1--18},
  year      = {2007}
}































@inproceedings{QualitasCorpus:APSEC:2010,
  author    = {Tempero, Ewan and Anslow, Craig and Dietrich, Jens and Han, Ted and Li, Jing and Lumpe, Markus and Melton, Hayden and Noble, James},
  title     = {{Qualitas Corpus: A Curated Collection of Java Code for Empirical Studies}},
  booktitle = {2010 Asia Pacific Software Engineering Conference (APSEC2010)},
  pages     = {336--345},
  month     = dec,
  year      = {2010},
  doi       = {http://dx.doi.org/10.1109/APSEC.2010.46}
}
























@article{soderberg2013extensible,
  author    = {Emma S{\"{o}}derberg and
               Torbj{\"{o}}rn Ekman and
               G{\"{o}}rel Hedin and
               Eva Magnusson},
  title     = {Extensible intraprocedural flow analysis at the abstract syntax tree
               level},
  journal   = {Sci. Comput. Program.},
  volume    = {78},
  number    = {10},
  pages     = {1809--1827},
  year      = {2013},
  url       = {https://doi.org/10.1016/j.scico.2012.02.002},
  doi       = {10.1016/J.SCICO.2012.02.002},
  timestamp = {Wed, 17 Feb 2021 21:55:46 +0100},
  biburl    = {https://dblp.org/rec/journals/scp/SoderbergEHM13.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}



@article{soderberg2012incremental,
  title     = {Incremental evaluation of reference attribute grammars using dynamic dependency tracking},
  author    = {S{\"o}derberg, Emma and Hedin, G{\"o}rel},
  year      = {2012},
  publisher = {Department of Computer Science, Lund University},
  note      = {LU-CS-TR:2012-249 (2012).}
}





@inproceedings{szaboinca2016,
  author    = {Szab\'{o}, Tam\'{a}s and Erdweg, Sebastian and Voelter, Markus},
  title     = {IncA: a DSL for the definition of incremental program analyses},
  year      = {2016},
  isbn      = {9781450338455},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2970276.2970298},
  doi       = {10.1145/2970276.2970298},
  abstract  = {Program analyses support software developers, for example, through error detection, code-quality assurance, and by enabling compiler optimizations and refactorings. To provide real-time feedback to developers within IDEs, an analysis must run efficiently even if the analyzed code base is large.  To achieve this goal, we present a domain-specific language called IncA for the definition of efficient incremental program analyses that update their result as the program changes. IncA compiles analyses into graph patterns and relies on existing incremental matching algorithms. To scale IncA analyses to large programs, we describe optimizations that reduce caching and prune change propagation. Using IncA, we have developed incremental control flow and points-to analysis for C, well-formedness checks for DSLs, and 10 FindBugs checks for Java. Our evaluation demonstrates significant speedups for all analyses compared to their non-incremental counterparts.},
  booktitle = {Proceedings of the 31st IEEE/ACM International Conference on Automated Software Engineering},
  pages     = {320–331},
  numpages  = {12},
  keywords  = {Static Analysis, Language Workbench, Incremental Computation, Domain-specific Language},
  location  = {Singapore, Singapore},
  series    = {ASE '16}
}














@misc{errorprone,
  author       = {{Google}},
  title        = {{Error Prone}: A static analysis tool for Java},
  howpublished = {\url{https://errorprone.info/}},
  year         = {2022},
  note         = {Accessed: 2024-06-28}
}

@misc{nullaway,
  author       = {{Uber Technologies, Inc.}},
  title        = {{NullAway}: A tool for eliminating {NullPointerExceptions} (NPEs) in {Java} programs},
  howpublished = {\url{https://github.com/uber/NullAway}},
  year         = {2022},
  note         = {Accessed: 2024-06-28}
}

@article{ayah2008using,
  author   = {Ayewah, Nathaniel and Pugh, William and Hovemeyer, David and Morgenthaler, J. David and Penix, John},
  journal  = {IEEE Software},
  title    = {Using Static Analysis to Find Bugs},
  year     = {2008},
  volume   = {25},
  number   = {5},
  pages    = {22-29},
  keywords = {Computer bugs;Java;Software tools;Testing;Security;Educational institutions;Open source software;Software quality;Production;Programming;static analysis;FindBugs;code quality;bug patterns;software defects;software quality},
  doi      = {10.1109/MS.2008.130}
}



@article{distefano2019scaling,
  author     = {Distefano, Dino and F\"{a}hndrich, Manuel and Logozzo, Francesco and O'Hearn, Peter W.},
  title      = {Scaling static analyses at Facebook},
  year       = {2019},
  issue_date = {August 2019},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {62},
  number     = {8},
  issn       = {0001-0782},
  url        = {https://doi.org/10.1145/3338112},
  doi        = {10.1145/3338112},
  abstract   = {Key lessons for designing static analyses tools deployed to find bugs in hundreds of millions of lines of code.},
  journal    = {Commun. ACM},
  month      = {jul},
  pages      = {62–70},
  numpages   = {9}
}


@article{risberg2024property-journal,
  author     = {Anton Risberg Alak{\"{u}}la and
                G{\"{o}}rel Hedin and
                Niklas Fors and
                Adrian Pop},
  title      = {Property probes: Live exploration of program analysis results},
  journal    = {J. Syst. Softw.},
  volume     = {211},
  pages      = {111980},
  year       = {2024},
  url        = {https://doi.org/10.1016/j.jss.2024.111980},
  doi_ignore = {10.1016/J.JSS.2024.111980},
  timestamp  = {Tue, 18 Jun 2024 09:55:53 +0200},
  biburl     = {https://dblp.org/rec/journals/jss/AlakulaHFP24.bib},
  bibsource  = {dblp computer science bibliography, https://dblp.org}
}













@misc{sinfoj2023,
  title  = {SinfoJ: A simple Information Flow Analysis with Reference Attribute Grammars},
  author = {Max Soller},
  year   = 2023,
  note   = {Available at \url{http://lup.lub.lu.se/student-papers/record/9149210}},
  school = {Lund University},
  type   = {Master's thesis}
}


@inproceedings{jflow1999,
  author    = {Andrew C. Myers},
  editor    = {Andrew W. Appel and
               Alex Aiken},
  title     = {JFlow: Practical Mostly-Static Information Flow Control},
  booktitle = {{POPL} '99, Proceedings of the 26th {ACM} {SIGPLAN-SIGACT} Symposium
               on Principles of Programming Languages, San Antonio, TX, USA, January
               20-22, 1999},
  pages     = {228--241},
  publisher = {{ACM}},
  year      = {1999},
  url       = {https://doi.org/10.1145/292540.292561},
  doi       = {10.1145/292540.292561},
  timestamp = {Tue, 06 Nov 2018 11:07:43 +0100},
  biburl    = {https://dblp.org/rec/conf/popl/Myers99.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}


@misc{clang,
  title        = {Clang Static Analyzer},
  author       = {{LLVM Project}},
  howpublished = {\url{https://clang-analyzer.llvm.org/}},
  note         = {Accessed: 2024-07-23}
}

@misc{codeql,
  title        = {CodeQL},
  author       = {{GitHub}},
  howpublished = {\url{https://codeql.github.com/}},
  note         = {Accessed: 2024-07-23}
}

@inproceedings{livshits2005finding,
  author    = {Livshits, Benjamin and Lam, Monica S.},
  title     = {Finding Security Vulnerabilities in Java Applications with Static Analysis},
  booktitle = {Proceedings of the 14th Usenix Security Symposium},
  year      = {2005},
  pages     = {271--286},
  publisher = {USENIX Association},
  address   = {Berkeley, CA, USA},
  url       = {https://www.usenix.org/legacy/event/sec05/tech/full_papers/livshits/livshits.pdf}
}

@inproceedings{lam2011soot,
  title     = {The Soot framework for Java program analysis: a retrospective},
  author    = {Lam, Patrick and Bodden, Eric and Lhot{\'a}k, Ondrej and Hendren, Laurie},
  booktitle = {Cetus Users and Compiler Infastructure Workshop (CETUS 2011)},
  volume    = {15},
  number    = {35},
  year      = {2011}
}

@inproceedings{sloane2014monto,
  author    = {Sloane, Anthony M. and Roberts, Matthew and Buckley, Scott and Muscat, Shaun},
  editor    = {Combemale, Beno{\^i}t and Pearce, David J. and Barais, Olivier and Vinju, Jurgen J.},
  title     = {Monto: A Disintegrated Development Environment},
  booktitle = {Software Language Engineering},
  year      = {2014},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {211--220},
  abstract  = {Integrated development environments play a central role in the life of many software developers. Integrating new functionality into these environments is non-trivial and forms a significant barrier to entry. We describe our Monto architecture which aims to address this problem. Monto components communicate via text messages across an off-the-shelf messaging layer. The architecture imposes limited constraints which enables easy combination of components to form an environment. A prototype implementation shows that this approach is practical and shows promise for full-featured development environments.},
  isbn      = {978-3-319-11245-9}
}

@inproceedings{szabo2021incremental,
  title     = {Incremental whole-program analysis in Datalog with lattices},
  author    = {Szab{\'o}, Tam{\'a}s and Erdweg, Sebastian and Bergmann, G{\'a}bor},
  booktitle = {Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
  pages     = {1--15},
  year      = {2021}
}
