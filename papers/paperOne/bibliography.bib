@article{DBLP:journals/cacm/Knuth74,
  author    = {Donald E. Knuth},
  title     = {{Computer Programming as an Art}},
  journal   = {Commun. {ACM}},
  volume    = {17},
  number    = {12},
  pages     = {667--673},
  year      = {1974},
  doi       = {10.1145/361604.361612},
  timestamp = {Tue, 07 Jun 2011 16:50:57 +0200},
  biburl    = {http://dblp.uni-trier.de/rec/bib/journals/cacm/Knuth74},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}

@article{DBLP:journals/cacm/Dijkstra68a,
  author    = {Edsger W. Dijkstra},
  title     = {Letters to the editor: go to statement considered harmful},
  journal   = {Commun. {ACM}},
  volume    = {11},
  number    = {3},
  pages     = {147--148},
  year      = {1968},
  doi       = {10.1145/362929.362947},
  timestamp = {Thu, 09 Feb 2006 13:19:49 +0100},
  biburl    = {http://dblp.uni-trier.de/rec/bib/journals/cacm/Dijkstra68a},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}

@book{DBLP:books/mk/GrayR93,
  author    = {Jim Gray and
               Andreas Reuter},
  title     = {Transaction Processing: Concepts and Techniques},
  publisher = {Morgan Kaufmann},
  year      = {1993},
  isbn      = {1-55860-190-2},
  timestamp = {Thu, 05 Nov 2015 19:53:28 +0100},
  biburl    = {http://dblp.uni-trier.de/rec/bib/books/mk/GrayR93},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}



@inproceedings{DBLP:conf/focs/HopcroftPV75,
  author    = {{John E.} Hopcroft and
               {Wolfgang J.} Paul and
               {Leslie G.} Valiant},
  title     = {On Time versus Space and Related Problems},
  booktitle = {16th Annual Symposium on Foundations of Computer Science, Berkeley,
               California, USA, October 13-15, 1975},
  pages     = {57--64},
  year      = {1975},
  crossref  = {DBLP:conf/focs/FOCS16},
  doi       = {10.1109/SFCS.1975.23},
  timestamp = {Tue, 16 Dec 2014 09:57:24 +0100},
  biburl    = {http://dblp.uni-trier.de/rec/bib/conf/focs/HopcroftPV75},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}

@proceedings{DBLP:conf/focs/FOCS16,
  title     = {16th Annual Symposium on Foundations of Computer Science, Berkeley,
               California, USA, October 13-15, 1975},
  publisher = {{IEEE} Computer Society},
  year      = {1975},
  timestamp = {Mon, 15 Dec 2014 18:48:44 +0100},
  biburl    = {http://dblp.uni-trier.de/rec/bib/conf/focs/FOCS16},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}









@inproceedings{ekman2007jastadd,
  title     = {The jastadd extensible java compiler},
  author    = {Ekman, Torbj{\"o}rn and Hedin, G{\"o}rel},
  booktitle = {Proceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented programming systems and applications},
  pages     = {1--18},
  year      = {2007}
}




@article{a42d66bd599e4d45b783a5de8b652497,
	title = "Circular Reference Attributed Grammars - their Evaluation and Applications",
	abstract = "This paper presents a combination of Reference Attributed Grammars (RAGs) and Circular Attribute Grammars (CAGs). While RAGs allow the direct and easy specification of non-locally dependent information, CAGs allow iterative fixed-point computations to be expressed directly using recursive (circular) equations. We demonstrate how the combined formalism, Circular Reference Attributed Grammars (CRAGs), can take advantage of both these strengths, making it possible to express solutions to many problems in an easy way. We exemplify with the specification and computation of the nullable, first, and follow sets used in parser construction, a problem which is highly recursive and normally programmed by hand using an iterative algorithm. We also present a general demand-driven evaluation algorithm for CRAGs and some optimizations of it. The approach has been implemented and experimental results include computations on a series of grammars including that of Java 1.2. We also revisit some of the classical examples of CAGs and show how their solutions are facilitated by CRAGs.",
	keywords = "fixed-point computations, Attribute grammars, Circular grammars",
	author = "Eva Magnusson and G{\"o}rel Hedin",
	year = "2007",
	doi = "10.1016/j.scico.2005.06.005",
	language = "English",
	volume = "68",
	pages = "21--37",
	journal = "Science of Computer Programming",
	issn = "0167-6423",
	publisher = "Elsevier",
	number = "1",
}











@inproceedings{deroover2011soul,
  author = {De Roover, Coen and Noguera, Carlos and Kellens, Andy and Jonckers, Vivane},
  title = {The SOUL Tool Suite for Querying Programs in Symbiosis with Eclipse},
  year = {2011},
  isbn = {9781450309356},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/2093157.2093168},
  booktitle = {Proceedings of the 9th International Conference on Principles and Practice of Programming in Java},
  pages = {71--80},
  numpages = {10},
  keywords = {logic programming, program analysis, integrated development environments, program queries, software engineering tools},
  location = {Kongens Lyngby, Denmark},
  series = {PPPJ '11}
}


@inproceedings{bodden2012inter,
  title={Inter-procedural data-flow analysis with ifds/ide and soot},
  author={Bodden, Eric},
  booktitle={Proceedings of the ACM SIGPLAN International Workshop on State of the Art in Java Program analysis},
  pages={3--8},
  year={2012}
}



@article{szabo2018inca,
  author = {Szab\'{o}, Tam\'{a}s and Bergmann, G\'{a}bor and Erdweg, Sebastian and Voelter, Markus},
  title = {Incrementalizing Lattice-Based Program Analyses in Datalog},
  year = {2018},
  issue_date = {November 2018},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {2},
  number = {OOPSLA},
  url = {https://doi.org/10.1145/3276509},
  doi = {10.1145/3276509},
  abstract = {Program analyses detect errors in code, but when code changes frequently as in an IDE, repeated re-analysis from-scratch is unnecessary: It leads to poor performance unless we give up on precision and recall. Incremental program analysis promises to deliver fast feedback without giving up on precision or recall by deriving a new analysis result from the previous one. However, Datalog and other existing frameworks for incremental program analysis are limited in expressive power: They only support the powerset lattice as representation of analysis results, whereas many practically relevant analyses require custom lattices and aggregation over lattice values. To this end, we present a novel algorithm called DRedL that supports incremental maintenance of recursive lattice-value aggregation in Datalog. The key insight of DRedL is to dynamically recognize increasing replacements of old lattice values by new ones, which allows us to avoid the expensive deletion of the old value. We integrate DRedL into the analysis framework IncA and use IncA to realize incremental implementations of strong-update points-to analysis and string analysis for Java. As our performance evaluation demonstrates, both analyses react to code changes within milliseconds.},
  journal = {Proc. ACM Program. Lang.},
  month = oct,
  articleno = {139},
  numpages = {29},
  keywords = {Incremental Computing, Static Analysis, Domain-Specific Language, Lattice, Datalog, Language Workbench}
}

@inproceedings{lawall10coccinelle,
  TITLE = {{Finding Error Handling Bugs in OpenSSL Using Coccinelle}},
  AUTHOR = {Lawall, Julia and Laurie, Ben and Hansen, Ren{\'e} Rydhof and Palix, Nicolas and Muller, Gilles},
  URL = {https://hal.archives-ouvertes.fr/hal-00940375},
  BOOKTITLE = {{European Dependable Computing Conference}},
  ADDRESS = {Valencia, Spain},
  PAGES = {191-196},
  YEAR = {2010},
  MONTH = Apr,
  DOI = {10.1109/EDCC.2010.31},
  KEYWORDS = {Software quality ; Software evolution ; Static code analysis},
  HAL_ID = {hal-00940375},
  HAL_VERSION = {v1},
}


@inproceedings{visser2002concretesyntax,
  author = {Visser, Eelco},
  title = {Meta-Programming with Concrete Object Syntax},
  year = {2002},
  isbn = {3540442847},
  publisher = {Springer-Verlag},
  address = {Berlin, Heidelberg},
  abstract = {Meta programs manipulate structured representations, i.e., abstract syntax trees, of programs. The conceptual distance between the concrete syntax meta-programmers use to reason about programs and the notation for abstract syntax manipulation provided by general purpose (meta-) programming languages is too great for many applications. In this paper it is shown how the syntax definition formalism SDF can be employed to fit any meta-programming language with concrete syntax notation for composing and analyzing object programs. As a case study, the addition of concrete syntax to the program transformation language Stratego is presented. The approach is then generalized to arbitrary meta-languages.},
  booktitle = {Proceedings of the 1st ACM SIGPLAN/SIGSOFT Conference on Generative Programming and Component Engineering},
  pages = {299–315},
  numpages = {17},
  series = {GPCE '02}
}



@article{rice1953classes,
  title     = {Classes of recursively enumerable sets and their decision problems},
  author    = {Rice, Henry Gordon},
  journal   = {Transactions of the American Mathematical society},
  volume    = {74},
  number    = {2},
  pages     = {358--366},
  year      = {1953},
  publisher = {JSTOR}
}




@misc{rusling1999linux,
  title  = {The linux kernel},
  author = {Rusling, David A},
  year   = {1999}
}



@misc{findbugs,
  title        = {{FindBugs}},
  publisher    = {FindBugs},
  howpublished = {\url{http://findbugs.sourceforge.net/}},
  note         = {{Accessed:} 2023-02-17},
  key          = {FindBugs}
}

@article{spoon,
author = {Pawlak, Renaud and Monperrus, Martin and Petitprez, Nicolas and Noguera, Carlos and Seinturier, Lionel},
title = {SPOON: A library for implementing analyses and transformations of Java source code},
journal = {Software: Practice and Experience},
volume = {46},
number = {9},
pages = {1155-1179},
keywords = {source code analysis, source code transformation, metaprogramming},
doi = {https://doi.org/10.1002/spe.2346},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/spe.2346},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/spe.2346},
abstract = {Summary This paper presents SPOON, a library for the analysis and transformation of Java source code. SPOON enables Java developers to write a large range of domain-specific analyses and transformations in an easy and concise manner. SPOON analyses and transformations are written in plain Java. With SPOON, developers do not need to dive into parsing, to hack a compiler infrastructure, or to master a new formalism. Copyright © 2015 John Wiley \& Sons, Ltd.},
year = {2016}
}


@article{CREMERS197586,
title = {Context-free grammar forms},
journal = {Journal of Computer and System Sciences},
volume = {11},
number = {1},
pages = {86-117},
year = {1975},
issn = {0022-0000},
doi = {https://doi.org/10.1016/S0022-0000(75)80051-1},
url = {https://www.sciencedirect.com/science/article/pii/S0022000075800511},
author = {Armin Cremers and Seymour Ginsburg},
abstract = {In an attempt to provide a unified theory of grammars, a model is introduced which has two components. The first is a “grammar form,” which provides the general structure of the productions in the grammars to be defined. The second is an “interpretation”, which yields a specific grammar. By considering all interpretations, a family of grammars, intimately related to that of the grammar form, is obtained. Many of the well-known families of grammars occur as special instances. Attention is focused on the situation when the productions in the grammar form are context free. Necessary and sufficient conditions on a context-free grammar form are given in order for it, to yield, respectively, exactly the finite languages, the regular sets, the linear context-free languages, and all the context-free languages. Each context-free grammar form can be replaced by another, yielding the same family of languages, in which the underlying grammar is sequential. Of special interest to language theory is the fact the family of languages obtained from each context-free grammar form is a full principal semi-AFL.}
}

@article{Kam1977,
  author = {Kam, J.B. and Ullman, J.D.},
  title = {Monotone data flow analysis frameworks},
  journal = {Acta Informatica},
  volume = {7},
  pages = {305--317},
  year = {1977},
  doi = {https://doi.org/10.1007/BF00290339}
}




@book{Birkhoff1967,
  author = {Birkhoff, Garrett},
  title = {Introduction to Lattices and Order},
  publisher = {Cambridge University Press},
  year = {1967},
}



@article{Hesse1874,
  author = {Hesse, Otto},
  title = {Beiträge zur Begründung der projektiven Geometrie},
  journal = {Mathematische Annalen},
  volume = {8},
  pages = {476--486},
  year = {1874},
}

